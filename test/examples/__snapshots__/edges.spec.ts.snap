// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`client > client 1`] = `
{
  "cleanFn": [Function],
  "outputFiles": {
    "examples/edges/client.client.ts": "/**
 * Generated by @skyleague/therefore@v1.0.0-local
 * Do not manually touch this
 */
/* eslint-disable */

import type { IncomingHttpHeaders } from 'node:http'

import type { DefinedError } from 'ajv'
import { got } from 'got'
import type { CancelableRequest, Got, Options, OptionsInit, Response } from 'got'

/**
 * openapi
 */
export class DoubleSuccessClient {
    public client: Got

    public constructor({
        prefixUrl,
        options,
    }: {
        prefixUrl: string
        options?: Options | OptionsInit
    }) {
        this.client = got.extend(...[{ prefixUrl, throwHttpErrors: false }, options].filter((o): o is Options => o !== undefined))
    }

    public getEmployees(): Promise<
        | SuccessResponse<'200', unknown>
        | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
        | FailureResponse<StatusCode<1 | 3 | 4 | 5>, string, 'response:statuscode', IncomingHttpHeaders>
    > {
        return this.awaitResponse(
            this.client.get('employees', {
                responseType: 'text',
            }),
            {
                200: { parse: (x: unknown) => ({ right: x }) },
            },
        ) as ReturnType<this['getEmployees']>
    }

    public getImage(): Promise<
        | SuccessResponse<'200', unknown>
        | SuccessResponse<'202', unknown>
        | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
        | FailureResponse<StatusCode<1 | 3 | 4 | 5>, string, 'response:statuscode', IncomingHttpHeaders>
    > {
        return this.awaitResponse(
            this.client.get('image', {
                responseType: 'text',
            }),
            {
                200: { parse: (x: unknown) => ({ right: x }) },
                202: { parse: (x: unknown) => ({ right: x }) },
            },
        ) as ReturnType<this['getImage']>
    }

    public async awaitResponse<
        I,
        S extends Record<PropertyKey, { parse: (o: I) => { left: DefinedError[] } | { right: unknown } } | undefined>,
    >(response: CancelableRequest<Response<I>>, schemas: S) {
        const result = await response
        const status =
            result.statusCode < 200
                ? 'informational'
                : result.statusCode < 300
                  ? 'success'
                  : result.statusCode < 400
                    ? 'redirection'
                    : result.statusCode < 500
                      ? 'client-error'
                      : 'server-error'
        const validator = schemas[result.statusCode] ?? schemas.default
        const body = validator?.parse?.(result.body)
        if (result.statusCode < 200 || result.statusCode >= 300) {
            return {
                statusCode: result.statusCode.toString(),
                status,
                headers: result.headers,
                left: body !== undefined && 'right' in body ? body.right : result.body,
                validationErrors: body !== undefined && 'left' in body ? body.left : undefined,
                where: 'response:statuscode',
            }
        }
        if (body === undefined || 'left' in body) {
            return {
                statusCode: result.statusCode.toString(),
                status,
                headers: result.headers,
                left: result.body,
                validationErrors: body?.left,
                where: 'response:body',
            }
        }
        return { statusCode: result.statusCode.toString(), status, headers: result.headers, right: result.body }
    }
}

/**
 * openapi
 */
export class Edges {
    public client: Got

    public constructor({
        prefixUrl,
        options,
    }: {
        prefixUrl: string
        options?: Options | OptionsInit
    }) {
        this.client = got.extend(...[{ prefixUrl, throwHttpErrors: false }, options].filter((o): o is Options => o !== undefined))
    }

    public getEmployees(): Promise<
        | SuccessResponse<'200', unknown>
        | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
        | FailureResponse<StatusCode<1 | 3 | 4 | 5>, string, 'response:statuscode', IncomingHttpHeaders>
    > {
        return this.awaitResponse(
            this.client.get('employees', {
                responseType: 'text',
            }),
            {
                200: { parse: (x: unknown) => ({ right: x }) },
            },
        ) as ReturnType<this['getEmployees']>
    }

    public getImage(): Promise<
        | SuccessResponse<'200', unknown>
        | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
        | FailureResponse<StatusCode<1 | 3 | 4 | 5>, string, 'response:statuscode', IncomingHttpHeaders>
    > {
        return this.awaitResponse(
            this.client.get('image', {
                responseType: 'text',
            }),
            {
                200: { parse: (x: unknown) => ({ right: x }) },
            },
        ) as ReturnType<this['getImage']>
    }

    public async awaitResponse<
        I,
        S extends Record<PropertyKey, { parse: (o: I) => { left: DefinedError[] } | { right: unknown } } | undefined>,
    >(response: CancelableRequest<Response<I>>, schemas: S) {
        const result = await response
        const status =
            result.statusCode < 200
                ? 'informational'
                : result.statusCode < 300
                  ? 'success'
                  : result.statusCode < 400
                    ? 'redirection'
                    : result.statusCode < 500
                      ? 'client-error'
                      : 'server-error'
        const validator = schemas[result.statusCode] ?? schemas.default
        const body = validator?.parse?.(result.body)
        if (result.statusCode < 200 || result.statusCode >= 300) {
            return {
                statusCode: result.statusCode.toString(),
                status,
                headers: result.headers,
                left: body !== undefined && 'right' in body ? body.right : result.body,
                validationErrors: body !== undefined && 'left' in body ? body.left : undefined,
                where: 'response:statuscode',
            }
        }
        if (body === undefined || 'left' in body) {
            return {
                statusCode: result.statusCode.toString(),
                status,
                headers: result.headers,
                left: result.body,
                validationErrors: body?.left,
                where: 'response:body',
            }
        }
        return { statusCode: result.statusCode.toString(), status, headers: result.headers, right: result.body }
    }
}

export type Status<Major> = Major extends string
    ? Major extends \`1\${number}\`
        ? 'informational'
        : Major extends \`2\${number}\`
          ? 'success'
          : Major extends \`3\${number}\`
            ? 'redirection'
            : Major extends \`4\${number}\`
              ? 'client-error'
              : 'server-error'
    : undefined
export interface SuccessResponse<StatusCode extends string, T> {
    statusCode: StatusCode
    status: Status<StatusCode>
    headers: IncomingHttpHeaders
    right: T
}
export interface FailureResponse<StatusCode = string, T = unknown, Where = never, Headers = IncomingHttpHeaders> {
    statusCode: StatusCode
    status: Status<StatusCode>
    headers: Headers
    validationErrors: DefinedError[] | undefined
    left: T
    where: Where
}
export type StatusCode<Major extends number = 1 | 2 | 3 | 4 | 5> = \`\${Major}\${number}\`

/**
 * swagger
 */
export class SwaggerEdges {
    public client: Got

    public constructor({
        prefixUrl,
        options,
    }: {
        prefixUrl: string
        options?: Options | OptionsInit
    }) {
        this.client = got.extend(...[{ prefixUrl, throwHttpErrors: false }, options].filter((o): o is Options => o !== undefined))
    }

    public getJsonResponse(): Promise<
        | SuccessResponse<'200', unknown>
        | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
        | FailureResponse<StatusCode<1 | 3 | 4 | 5>, string, 'response:statuscode', IncomingHttpHeaders>
    > {
        return this.awaitResponse(
            this.client.get('json-response', {
                responseType: 'text',
            }),
            {
                200: { parse: (x: unknown) => ({ right: x }) },
            },
        ) as ReturnType<this['getJsonResponse']>
    }

    public async awaitResponse<
        I,
        S extends Record<PropertyKey, { parse: (o: I) => { left: DefinedError[] } | { right: unknown } } | undefined>,
    >(response: CancelableRequest<Response<I>>, schemas: S) {
        const result = await response
        const status =
            result.statusCode < 200
                ? 'informational'
                : result.statusCode < 300
                  ? 'success'
                  : result.statusCode < 400
                    ? 'redirection'
                    : result.statusCode < 500
                      ? 'client-error'
                      : 'server-error'
        const validator = schemas[result.statusCode] ?? schemas.default
        const body = validator?.parse?.(result.body)
        if (result.statusCode < 200 || result.statusCode >= 300) {
            return {
                statusCode: result.statusCode.toString(),
                status,
                headers: result.headers,
                left: body !== undefined && 'right' in body ? body.right : result.body,
                validationErrors: body !== undefined && 'left' in body ? body.left : undefined,
                where: 'response:statuscode',
            }
        }
        if (body === undefined || 'left' in body) {
            return {
                statusCode: result.statusCode.toString(),
                status,
                headers: result.headers,
                left: result.body,
                validationErrors: body?.left,
                where: 'response:body',
            }
        }
        return { statusCode: result.statusCode.toString(), status, headers: result.headers, right: result.body }
    }
}
",
  },
}
`;

exports[`locals 1`] = `
{
  "cleanFn": [Function],
  "outputFiles": {
    "examples/edges/locals.type.ts": "/**
 * Generated by @skyleague/therefore@v1.0.0-local
 * Do not manually touch this
 */
/* eslint-disable */

export interface Days {
    days: Days2[]
}

type Days2 = 'monday' | 'tuesday' | 'wednesday' | 'thursday' | 'friday' | 'saturday' | 'sunday'

type Local = string

type Local2 = string

export type Ref1 = Local

export type Ref2 = Local2

export type Unevaluated = string
",
  },
}
`;

exports[`optional 1`] = `
{
  "cleanFn": [Function],
  "outputFiles": {
    "examples/edges/optional.type.ts": "/**
 * Generated by @skyleague/therefore@v1.0.0-local
 * Do not manually touch this
 */
/* eslint-disable */

export type MadeOptionalRef = Original | undefined

export type OptionalString = string | undefined

export type OptionalUnknown = unknown

export type Original = string
",
  },
}
`;

exports[`validator 1`] = `
{
  "cleanFn": [Function],
  "outputFiles": {
    "examples/edges/schemas/validator.schema.js": "/* eslint-disable */
// @ts-nocheck
/**
 * Generated by Ajv https://ajv.js.org/guide/managing-schemas.html#standalone-validation-code
 */
"use strict";
/** @type {unknown} */
export const validate = validate10;export default validate10;const schema11 = {"$schema":"http://json-schema.org/draft-07/schema#","title":"Validator","type":"object","properties":{"foo":{"type":"string"}},"required":["foo"],"additionalProperties":true};function validate10(data, {instancePath="", parentData, parentDataProperty, rootData=data}={}){let vErrors = null;let errors = 0;if(errors === 0){if(data && typeof data == "object" && !Array.isArray(data)){let missing0;if((data.foo === undefined) && (missing0 = "foo")){validate10.errors = [{instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: missing0},message:"must have required property '"+missing0+"'"}];return false;}else {if(data.foo !== undefined){if(typeof data.foo !== "string"){validate10.errors = [{instancePath:instancePath+"/foo",schemaPath:"#/properties/foo/type",keyword:"type",params:{type: "string"},message:"must be string"}];return false;}}}}else {validate10.errors = [{instancePath,schemaPath:"#/type",keyword:"type",params:{type: "object"},message:"must be object"}];return false;}}validate10.errors = vErrors;return errors === 0;};validate.schema=schema11;",
    "examples/edges/validator.type.ts": "/**
 * Generated by @skyleague/therefore@v1.0.0-local
 * Do not manually touch this
 */
/* eslint-disable */

import type { DefinedError, ValidateFunction } from 'ajv'

import { validate as ValidatorValidator } from './schemas/validator.schema.js'

export interface Validator {
    foo: string
}

export const Validator = {
    validate: ValidatorValidator as ValidateFunction<Validator>,
    get schema() {
        return Validator.validate.schema
    },
    get errors() {
        return Validator.validate.errors ?? undefined
    },
    is: (o: unknown): o is Validator => Validator.validate(o) === true,
    parse: (o: unknown): { right: Validator } | { left: DefinedError[] } => {
        if (Validator.is(o)) {
            return { right: o }
        }
        return { left: (Validator.errors ?? []) as DefinedError[] }
    },
} as const
",
  },
}
`;
