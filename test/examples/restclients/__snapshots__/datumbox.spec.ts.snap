// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`output generation - ajv 1`] = `
{
  "cleanFn": [Function],
  "outputFiles": {
    "examples/restclients/ajv/datumbox/datumbox.client.ts": "/**
* Generated by @skyleague/therefore
* Do not manually touch this
*/
// biome-ignore-all lint: this file is generated
/* eslint-disable */

import type { IncomingHttpHeaders } from 'node:http'

import type { DefinedError } from 'ajv'
import { got } from 'got'
import type { CancelableRequest, Got, Options, OptionsInit, Response } from 'got'

import { AdultContentDetectionRequest, CommercialDetectionRequest, DocumentSimilarityRequest, EducationalDetectionRequest, GenderDetectionRequest, KeywordExtractionRequest, LanguageDetectionRequest, ReadabilityAssessmentRequest, SentimentAnalysisRequest, SpamDetectionRequest, SubjectivityAnalysisRequest, TextExtractionRequest, TopicClassificationRequest, TwitterSentimentAnalysisRequest } from './datumbox.type.js'

/**
 * api.datumbox.com
 * 
 * Datumbox offers a Machine Learning platform composed of 14 classifiers and Natural Language processing functions. Functions include sentiment analysis, topic classification, readability assessment, language detection, and much more.
 */
export class Datumbox {
    public client: Got

    public constructor(
    {
        prefixUrl = 'http://api.datumbox.com/',
        options,
        client = got
    }: {
        prefixUrl?: string | 'http://api.datumbox.com/',
        options?: Options | OptionsInit,
        client?: Got
    } = {}) {
        this.client = client.extend(...[{ prefixUrl, throwHttpErrors: false }, options].filter((o): o is Options => o !== undefined))
    }


    /**
     * POST /1.0/AdultContentDetection.json
     * 
     * Classifies the Document as adult or noadult
     * 
     * The Adult Content Detection function classifies the documents as adult or noadult based on their context. It can be used to detect whether a document contains content unsuitable for minors.
     */
    public adultContentDetection({body}: {body: AdultContentDetectionRequest}): Promise<
    | SuccessResponse<'200', unknown>
    | FailureResponse<undefined, unknown, 'request:body', undefined>
    | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
    | FailureResponse<StatusCode<1 | 3 | 4 | 5>, string, 'response:statuscode', IncomingHttpHeaders>
    >
    {
        const _body = this.validateRequestBody(AdultContentDetectionRequest, body)
        if ('left' in _body) {
        return Promise.resolve(_body)
        }


        return this.awaitResponse(this.client.post('1.0/AdultContentDetection.json', {
            form: _body.right,responseType: 'text',
        }), {
            200: { parse: (x: unknown) => ({ right: x }) },
        }) as ReturnType<this["adultContentDetection"]>
    }

    /**
     * POST /1.0/CommercialDetection.json
     * 
     * Classifies the Document as commercial or nocommercial
     * 
     * The Commercial Detection function labels the documents as commercial or non-commercial based on their keywords and expressions. It can be used to detect whether a website is commercial or not.
     */
    public commercialDetection({body}: {body: CommercialDetectionRequest}): Promise<
    | SuccessResponse<'200', unknown>
    | FailureResponse<undefined, unknown, 'request:body', undefined>
    | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
    | FailureResponse<StatusCode<1 | 3 | 4 | 5>, string, 'response:statuscode', IncomingHttpHeaders>
    >
    {
        const _body = this.validateRequestBody(CommercialDetectionRequest, body)
        if ('left' in _body) {
        return Promise.resolve(_body)
        }


        return this.awaitResponse(this.client.post('1.0/CommercialDetection.json', {
            form: _body.right,responseType: 'text',
        }), {
            200: { parse: (x: unknown) => ({ right: x }) },
        }) as ReturnType<this["commercialDetection"]>
    }

    /**
     * POST /1.0/DocumentSimilarity.json
     * 
     * Estimates the similarity between 2 Documents
     * 
     * The Document Similarity function estimates the degree of similarity between two documents. It can be used to detect duplicate webpages or detect plagiarism.
     */
    public documentSimilarity({body}: {body: DocumentSimilarityRequest}): Promise<
    | SuccessResponse<'200', unknown>
    | FailureResponse<undefined, unknown, 'request:body', undefined>
    | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
    | FailureResponse<StatusCode<1 | 3 | 4 | 5>, string, 'response:statuscode', IncomingHttpHeaders>
    >
    {
        const _body = this.validateRequestBody(DocumentSimilarityRequest, body)
        if ('left' in _body) {
        return Promise.resolve(_body)
        }


        return this.awaitResponse(this.client.post('1.0/DocumentSimilarity.json', {
            form: _body.right,responseType: 'text',
        }), {
            200: { parse: (x: unknown) => ({ right: x }) },
        }) as ReturnType<this["documentSimilarity"]>
    }

    /**
     * POST /1.0/EducationalDetection.json
     * 
     * Classifies the Document as educational or noeducational
     * 
     * The Educational Detection function classifies the documents as educational or non-educational based on their context. It can be used to detect whether a website is educational or not.
     */
    public educationalDetection({body}: {body: EducationalDetectionRequest}): Promise<
    | SuccessResponse<'200', unknown>
    | FailureResponse<undefined, unknown, 'request:body', undefined>
    | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
    | FailureResponse<StatusCode<1 | 3 | 4 | 5>, string, 'response:statuscode', IncomingHttpHeaders>
    >
    {
        const _body = this.validateRequestBody(EducationalDetectionRequest, body)
        if ('left' in _body) {
        return Promise.resolve(_body)
        }


        return this.awaitResponse(this.client.post('1.0/EducationalDetection.json', {
            form: _body.right,responseType: 'text',
        }), {
            200: { parse: (x: unknown) => ({ right: x }) },
        }) as ReturnType<this["educationalDetection"]>
    }

    /**
     * POST /1.0/GenderDetection.json
     * 
     * Gender Detection Service
     * 
     * The Gender Detection function identifies if a particular document is written-by or targets-to a man or a woman based on the context, the words and the idioms found in the text.
     */
    public genderDetection({body}: {body: GenderDetectionRequest}): Promise<
    | SuccessResponse<'200', unknown>
    | FailureResponse<undefined, unknown, 'request:body', undefined>
    | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
    | FailureResponse<StatusCode<1 | 3 | 4 | 5>, string, 'response:statuscode', IncomingHttpHeaders>
    >
    {
        const _body = this.validateRequestBody(GenderDetectionRequest, body)
        if ('left' in _body) {
        return Promise.resolve(_body)
        }


        return this.awaitResponse(this.client.post('1.0/GenderDetection.json', {
            form: _body.right,responseType: 'text',
        }), {
            200: { parse: (x: unknown) => ({ right: x }) },
        }) as ReturnType<this["genderDetection"]>
    }

    /**
     * POST /1.0/KeywordExtraction.json
     * 
     * Extracts the Keywords of the Document
     * 
     * The Keyword Extraction function enables you to extract from an arbitrary document all the keywords and word-combinations along with their occurrences in the text.
     */
    public keywordExtraction({body}: {body: KeywordExtractionRequest}): Promise<
    | SuccessResponse<'200', unknown>
    | FailureResponse<undefined, unknown, 'request:body', undefined>
    | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
    | FailureResponse<StatusCode<1 | 3 | 4 | 5>, string, 'response:statuscode', IncomingHttpHeaders>
    >
    {
        const _body = this.validateRequestBody(KeywordExtractionRequest, body)
        if ('left' in _body) {
        return Promise.resolve(_body)
        }


        return this.awaitResponse(this.client.post('1.0/KeywordExtraction.json', {
            form: _body.right,responseType: 'text',
        }), {
            200: { parse: (x: unknown) => ({ right: x }) },
        }) as ReturnType<this["keywordExtraction"]>
    }

    /**
     * POST /1.0/LanguageDetection.json
     * 
     * Identifies the Language of the Document
     * 
     * The Language Detection function identifies the natural language of the given document based on its words and context. This classifier is able to detect 96 different languages.
     */
    public languageDetection({body}: {body: LanguageDetectionRequest}): Promise<
    | SuccessResponse<'200', unknown>
    | FailureResponse<undefined, unknown, 'request:body', undefined>
    | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
    | FailureResponse<StatusCode<1 | 3 | 4 | 5>, string, 'response:statuscode', IncomingHttpHeaders>
    >
    {
        const _body = this.validateRequestBody(LanguageDetectionRequest, body)
        if ('left' in _body) {
        return Promise.resolve(_body)
        }


        return this.awaitResponse(this.client.post('1.0/LanguageDetection.json', {
            form: _body.right,responseType: 'text',
        }), {
            200: { parse: (x: unknown) => ({ right: x }) },
        }) as ReturnType<this["languageDetection"]>
    }

    /**
     * POST /1.0/ReadabilityAssessment.json
     * 
     * Evaluates the Readability of the Document
     * 
     * The Readability Assessment function determines the degree of readability of a document based on its terms and idioms. The texts are classified as basic, intermediate and advanced depending their difficulty.
     */
    public readabilityAssessment({body}: {body: ReadabilityAssessmentRequest}): Promise<
    | SuccessResponse<'200', unknown>
    | FailureResponse<undefined, unknown, 'request:body', undefined>
    | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
    | FailureResponse<StatusCode<1 | 3 | 4 | 5>, string, 'response:statuscode', IncomingHttpHeaders>
    >
    {
        const _body = this.validateRequestBody(ReadabilityAssessmentRequest, body)
        if ('left' in _body) {
        return Promise.resolve(_body)
        }


        return this.awaitResponse(this.client.post('1.0/ReadabilityAssessment.json', {
            form: _body.right,responseType: 'text',
        }), {
            200: { parse: (x: unknown) => ({ right: x }) },
        }) as ReturnType<this["readabilityAssessment"]>
    }

    /**
     * POST /1.0/SentimentAnalysis.json
     * 
     * Identifies the Sentiment of the Document
     * 
     * The Sentiment Analysis function classifies documents as positive, negative or neutral (lack of sentiment) depending on whether they express a positive, negative or neutral opinion.
     */
    public sentimentAnalysis({body}: {body: SentimentAnalysisRequest}): Promise<
    | SuccessResponse<'200', unknown>
    | FailureResponse<undefined, unknown, 'request:body', undefined>
    | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
    | FailureResponse<StatusCode<1 | 3 | 4 | 5>, string, 'response:statuscode', IncomingHttpHeaders>
    >
    {
        const _body = this.validateRequestBody(SentimentAnalysisRequest, body)
        if ('left' in _body) {
        return Promise.resolve(_body)
        }


        return this.awaitResponse(this.client.post('1.0/SentimentAnalysis.json', {
            form: _body.right,responseType: 'text',
        }), {
            200: { parse: (x: unknown) => ({ right: x }) },
        }) as ReturnType<this["sentimentAnalysis"]>
    }

    /**
     * POST /1.0/SpamDetection.json
     * 
     * Classifies the Document as spam or nospam
     * 
     * The Spam Detection function labels documents as spam or nospam by taking into account their context. It can be used to filter out spam emails and comments.
     */
    public spamDetection({body}: {body: SpamDetectionRequest}): Promise<
    | SuccessResponse<'200', unknown>
    | FailureResponse<undefined, unknown, 'request:body', undefined>
    | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
    | FailureResponse<StatusCode<1 | 3 | 4 | 5>, string, 'response:statuscode', IncomingHttpHeaders>
    >
    {
        const _body = this.validateRequestBody(SpamDetectionRequest, body)
        if ('left' in _body) {
        return Promise.resolve(_body)
        }


        return this.awaitResponse(this.client.post('1.0/SpamDetection.json', {
            form: _body.right,responseType: 'text',
        }), {
            200: { parse: (x: unknown) => ({ right: x }) },
        }) as ReturnType<this["spamDetection"]>
    }

    /**
     * POST /1.0/SubjectivityAnalysis.json
     * 
     * Classifies Document as Subjective or Objective
     * 
     * The Subjectivity Analysis function categorizes documents as subjective or objective based on their writing style. Texts that express personal opinions are labeled as subjective and the others as objective.
     */
    public subjectivityAnalysis({body}: {body: SubjectivityAnalysisRequest}): Promise<
    | SuccessResponse<'200', unknown>
    | FailureResponse<undefined, unknown, 'request:body', undefined>
    | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
    | FailureResponse<StatusCode<1 | 3 | 4 | 5>, string, 'response:statuscode', IncomingHttpHeaders>
    >
    {
        const _body = this.validateRequestBody(SubjectivityAnalysisRequest, body)
        if ('left' in _body) {
        return Promise.resolve(_body)
        }


        return this.awaitResponse(this.client.post('1.0/SubjectivityAnalysis.json', {
            form: _body.right,responseType: 'text',
        }), {
            200: { parse: (x: unknown) => ({ right: x }) },
        }) as ReturnType<this["subjectivityAnalysis"]>
    }

    /**
     * POST /1.0/TextExtraction.json
     * 
     * Extracts the clear text from Webpage
     * 
     * The Text Extraction function enables you to extract the important information from a given webpage. Extracting the clear text of the documents is an important step before any other analysis.
     */
    public textExtraction({body}: {body: TextExtractionRequest}): Promise<
    | SuccessResponse<'200', unknown>
    | FailureResponse<undefined, unknown, 'request:body', undefined>
    | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
    | FailureResponse<StatusCode<1 | 3 | 4 | 5>, string, 'response:statuscode', IncomingHttpHeaders>
    >
    {
        const _body = this.validateRequestBody(TextExtractionRequest, body)
        if ('left' in _body) {
        return Promise.resolve(_body)
        }


        return this.awaitResponse(this.client.post('1.0/TextExtraction.json', {
            form: _body.right,responseType: 'text',
        }), {
            200: { parse: (x: unknown) => ({ right: x }) },
        }) as ReturnType<this["textExtraction"]>
    }

    /**
     * POST /1.0/TopicClassification.json
     * 
     * Identifies the Topic of the Document
     * 
     * The Topic Classification function assigns documents in 12 thematic categories based on their keywords, idioms and jargon. It can be used to identify the topic of the texts.
     */
    public topicClassification({body}: {body: TopicClassificationRequest}): Promise<
    | SuccessResponse<'200', unknown>
    | FailureResponse<undefined, unknown, 'request:body', undefined>
    | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
    | FailureResponse<StatusCode<1 | 3 | 4 | 5>, string, 'response:statuscode', IncomingHttpHeaders>
    >
    {
        const _body = this.validateRequestBody(TopicClassificationRequest, body)
        if ('left' in _body) {
        return Promise.resolve(_body)
        }


        return this.awaitResponse(this.client.post('1.0/TopicClassification.json', {
            form: _body.right,responseType: 'text',
        }), {
            200: { parse: (x: unknown) => ({ right: x }) },
        }) as ReturnType<this["topicClassification"]>
    }

    /**
     * POST /1.0/TwitterSentimentAnalysis.json
     * 
     * Identifies the Sentiment of Twitter Messages
     * 
     * The Twitter Sentiment Analysis function allows you to perform Sentiment Analysis on Twitter. It classifies the tweets as positive, negative or neutral depending on their context.
     */
    public twitterSentimentAnalysis({body}: {body: TwitterSentimentAnalysisRequest}): Promise<
    | SuccessResponse<'200', unknown>
    | FailureResponse<undefined, unknown, 'request:body', undefined>
    | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
    | FailureResponse<StatusCode<1 | 3 | 4 | 5>, string, 'response:statuscode', IncomingHttpHeaders>
    >
    {
        const _body = this.validateRequestBody(TwitterSentimentAnalysisRequest, body)
        if ('left' in _body) {
        return Promise.resolve(_body)
        }


        return this.awaitResponse(this.client.post('1.0/TwitterSentimentAnalysis.json', {
            form: _body.right,responseType: 'text',
        }), {
            200: { parse: (x: unknown) => ({ right: x }) },
        }) as ReturnType<this["twitterSentimentAnalysis"]>
    }

    public validateRequestBody<Body>(
    parser: { parse: (o: unknown) => { left: DefinedError[] } | { right: Body } }, body: unknown )
    {
        const _body = parser.parse(body)
        if ('left' in _body)
        {
            return {success: false as const, statusCode: undefined, status: undefined, headers: undefined, left: body, validationErrors: _body.left, where: 'request:body' } satisfies FailureResponse<undefined, unknown, 'request:body', undefined>
        }
        return _body
    }

    public async awaitResponse<I, S extends Record<PropertyKey, { parse: (o: I) => { left: DefinedError[] } | { right: unknown } }>>(response: 
    CancelableRequest<NoInfer<Response<I>>>
    , schemas: S) {
        const result = await response
        const status = result.statusCode < 200 ? 'informational' : result.statusCode < 300 ? 'success' : result.statusCode < 400 ? 'redirection' : result.statusCode < 500 ? 'client-error' : 'server-error'
        const validator = schemas[result.statusCode] ?? schemas.default
        const body = validator?.parse?.(result.body)
        if (result.statusCode < 200 || result.statusCode >= 300)
        {
            return {success: false as const, statusCode: result.statusCode.toString(), status, headers: result.headers, left: body !== undefined && 'right' in body ? body.right : result.body, validationErrors: body !== undefined && 'left' in body ? body.left : undefined, where: 'response:statuscode' } 
        }
        if (body === undefined || 'left' in body)
        {
            return {success: body === undefined, statusCode: result.statusCode.toString(), status, headers: result.headers, left: result.body, validationErrors: body?.left, where: 'response:body' }
        }
        return {success: true as const, statusCode: result.statusCode.toString(), status, headers: result.headers, right: result.body }
    }
}

export type Status<Major> = Major extends string ? Major extends \`1\${number}\`? 'informational': Major extends \`2\${number}\` ? 'success' : Major extends \`3\${number}\` ? 'redirection' : Major extends \`4\${number}\` ? 'client-error' : 'server-error' : undefined
export interface SuccessResponse<StatusCode extends string, T> { success: true; statusCode: StatusCode; status: Status<StatusCode>; headers: IncomingHttpHeaders; right: T }
export interface FailureResponse<StatusCode = string, T = unknown, Where = never, Headers = IncomingHttpHeaders> {
success: false
statusCode: StatusCode
status: Status<StatusCode>
headers: Headers
validationErrors: DefinedError[] | undefined
left: T
where: Where
}
export type StatusCode<Major extends number = 1 | 2 | 3 | 4 | 5> = \`\${Major}\${number}\`



",
    "examples/restclients/ajv/datumbox/datumbox.type.ts": "/**
* Generated by @skyleague/therefore
* Do not manually touch this
*/
// biome-ignore-all lint: this file is generated
/* eslint-disable */

import type { DefinedError, ValidateFunction } from 'ajv'

import { validate as AdultContentDetectionRequestValidator } from './schemas/adult-content-detection-request.schema.js'
import { validate as CommercialDetectionRequestValidator } from './schemas/commercial-detection-request.schema.js'
import { validate as DocumentSimilarityRequestValidator } from './schemas/document-similarity-request.schema.js'
import { validate as EducationalDetectionRequestValidator } from './schemas/educational-detection-request.schema.js'
import { validate as GenderDetectionRequestValidator } from './schemas/gender-detection-request.schema.js'
import { validate as KeywordExtractionRequestValidator } from './schemas/keyword-extraction-request.schema.js'
import { validate as LanguageDetectionRequestValidator } from './schemas/language-detection-request.schema.js'
import { validate as ReadabilityAssessmentRequestValidator } from './schemas/readability-assessment-request.schema.js'
import { validate as SentimentAnalysisRequestValidator } from './schemas/sentiment-analysis-request.schema.js'
import { validate as SpamDetectionRequestValidator } from './schemas/spam-detection-request.schema.js'
import { validate as SubjectivityAnalysisRequestValidator } from './schemas/subjectivity-analysis-request.schema.js'
import { validate as TextExtractionRequestValidator } from './schemas/text-extraction-request.schema.js'
import { validate as TopicClassificationRequestValidator } from './schemas/topic-classification-request.schema.js'
import { validate as TwitterSentimentAnalysisRequestValidator } from './schemas/twitter-sentiment-analysis-request.schema.js'

export interface AdultContentDetectionRequest {
    /**
     * Your API Key
     */
    api_key: string
    /**
     * The text that you want to analyze. It should not contain HTML tags.
     */
    text?: (string | undefined)
}

export const AdultContentDetectionRequest = {
    validate: AdultContentDetectionRequestValidator as ValidateFunction<AdultContentDetectionRequest>,
    get schema() { return AdultContentDetectionRequest.validate.schema},
    get errors() { return AdultContentDetectionRequest.validate.errors ?? undefined },
    is: (o: unknown): o is AdultContentDetectionRequest => AdultContentDetectionRequest.validate(o) === true,
    parse: (o: unknown): { right: AdultContentDetectionRequest } | { left: DefinedError[] } => 
    {
        if(AdultContentDetectionRequest.is(o)) {
            return { right: o }
        }
        return { left: (AdultContentDetectionRequest.errors ?? []) as DefinedError[] }
    },
} as const


export interface CommercialDetectionRequest {
    /**
     * Your API Key
     */
    api_key: string
    /**
     * The text that you want to analyze. It should not contain HTML tags.
     */
    text?: (string | undefined)
}

export const CommercialDetectionRequest = {
    validate: CommercialDetectionRequestValidator as ValidateFunction<CommercialDetectionRequest>,
    get schema() { return CommercialDetectionRequest.validate.schema},
    get errors() { return CommercialDetectionRequest.validate.errors ?? undefined },
    is: (o: unknown): o is CommercialDetectionRequest => CommercialDetectionRequest.validate(o) === true,
    parse: (o: unknown): { right: CommercialDetectionRequest } | { left: DefinedError[] } => 
    {
        if(CommercialDetectionRequest.is(o)) {
            return { right: o }
        }
        return { left: (CommercialDetectionRequest.errors ?? []) as DefinedError[] }
    },
} as const


export interface DocumentSimilarityRequest {
    /**
     * Your API Key
     */
    api_key: string
    /**
     * The second text. It should not contain HTML tags.
     */
    copy?: (string | undefined)
    /**
     * The first text. It should not contain HTML tags.
     */
    original?: (string | undefined)
}

export const DocumentSimilarityRequest = {
    validate: DocumentSimilarityRequestValidator as ValidateFunction<DocumentSimilarityRequest>,
    get schema() { return DocumentSimilarityRequest.validate.schema},
    get errors() { return DocumentSimilarityRequest.validate.errors ?? undefined },
    is: (o: unknown): o is DocumentSimilarityRequest => DocumentSimilarityRequest.validate(o) === true,
    parse: (o: unknown): { right: DocumentSimilarityRequest } | { left: DefinedError[] } => 
    {
        if(DocumentSimilarityRequest.is(o)) {
            return { right: o }
        }
        return { left: (DocumentSimilarityRequest.errors ?? []) as DefinedError[] }
    },
} as const


export interface EducationalDetectionRequest {
    /**
     * Your API Key
     */
    api_key: string
    /**
     * The text that you want to analyze. It should not contain HTML tags.
     */
    text?: (string | undefined)
}

export const EducationalDetectionRequest = {
    validate: EducationalDetectionRequestValidator as ValidateFunction<EducationalDetectionRequest>,
    get schema() { return EducationalDetectionRequest.validate.schema},
    get errors() { return EducationalDetectionRequest.validate.errors ?? undefined },
    is: (o: unknown): o is EducationalDetectionRequest => EducationalDetectionRequest.validate(o) === true,
    parse: (o: unknown): { right: EducationalDetectionRequest } | { left: DefinedError[] } => 
    {
        if(EducationalDetectionRequest.is(o)) {
            return { right: o }
        }
        return { left: (EducationalDetectionRequest.errors ?? []) as DefinedError[] }
    },
} as const


export interface GenderDetectionRequest {
    /**
     * Your API Key
     */
    api_key: string
    /**
     * The text that you want to analyze. It should not contain HTML tags.
     */
    text?: (string | undefined)
}

export const GenderDetectionRequest = {
    validate: GenderDetectionRequestValidator as ValidateFunction<GenderDetectionRequest>,
    get schema() { return GenderDetectionRequest.validate.schema},
    get errors() { return GenderDetectionRequest.validate.errors ?? undefined },
    is: (o: unknown): o is GenderDetectionRequest => GenderDetectionRequest.validate(o) === true,
    parse: (o: unknown): { right: GenderDetectionRequest } | { left: DefinedError[] } => 
    {
        if(GenderDetectionRequest.is(o)) {
            return { right: o }
        }
        return { left: (GenderDetectionRequest.errors ?? []) as DefinedError[] }
    },
} as const


export interface KeywordExtractionRequest {
    /**
     * Your API Key
     */
    api_key: string
    /**
     * The number of keyword combinations (n-grams) that you wish to extract.
     */
    n?: (number | undefined)
    /**
     * The text that you want to analyze. It should not contain HTML tags.
     */
    text?: (string | undefined)
}

export const KeywordExtractionRequest = {
    validate: KeywordExtractionRequestValidator as ValidateFunction<KeywordExtractionRequest>,
    get schema() { return KeywordExtractionRequest.validate.schema},
    get errors() { return KeywordExtractionRequest.validate.errors ?? undefined },
    is: (o: unknown): o is KeywordExtractionRequest => KeywordExtractionRequest.validate(o) === true,
    parse: (o: unknown): { right: KeywordExtractionRequest } | { left: DefinedError[] } => 
    {
        if(KeywordExtractionRequest.is(o)) {
            return { right: o }
        }
        return { left: (KeywordExtractionRequest.errors ?? []) as DefinedError[] }
    },
} as const


export interface LanguageDetectionRequest {
    /**
     * Your API Key
     */
    api_key: string
    /**
     * The text that you want to analyze. It should not contain HTML tags.
     */
    text?: (string | undefined)
}

export const LanguageDetectionRequest = {
    validate: LanguageDetectionRequestValidator as ValidateFunction<LanguageDetectionRequest>,
    get schema() { return LanguageDetectionRequest.validate.schema},
    get errors() { return LanguageDetectionRequest.validate.errors ?? undefined },
    is: (o: unknown): o is LanguageDetectionRequest => LanguageDetectionRequest.validate(o) === true,
    parse: (o: unknown): { right: LanguageDetectionRequest } | { left: DefinedError[] } => 
    {
        if(LanguageDetectionRequest.is(o)) {
            return { right: o }
        }
        return { left: (LanguageDetectionRequest.errors ?? []) as DefinedError[] }
    },
} as const


export interface ReadabilityAssessmentRequest {
    /**
     * Your API Key
     */
    api_key: string
    /**
     * The text that you want to analyze. It should not contain HTML tags.
     */
    text?: (string | undefined)
}

export const ReadabilityAssessmentRequest = {
    validate: ReadabilityAssessmentRequestValidator as ValidateFunction<ReadabilityAssessmentRequest>,
    get schema() { return ReadabilityAssessmentRequest.validate.schema},
    get errors() { return ReadabilityAssessmentRequest.validate.errors ?? undefined },
    is: (o: unknown): o is ReadabilityAssessmentRequest => ReadabilityAssessmentRequest.validate(o) === true,
    parse: (o: unknown): { right: ReadabilityAssessmentRequest } | { left: DefinedError[] } => 
    {
        if(ReadabilityAssessmentRequest.is(o)) {
            return { right: o }
        }
        return { left: (ReadabilityAssessmentRequest.errors ?? []) as DefinedError[] }
    },
} as const


export interface SentimentAnalysisRequest {
    /**
     * Your API Key
     */
    api_key: string
    /**
     * The text that you want to analyze. It should not contain HTML tags.
     */
    text?: (string | undefined)
}

export const SentimentAnalysisRequest = {
    validate: SentimentAnalysisRequestValidator as ValidateFunction<SentimentAnalysisRequest>,
    get schema() { return SentimentAnalysisRequest.validate.schema},
    get errors() { return SentimentAnalysisRequest.validate.errors ?? undefined },
    is: (o: unknown): o is SentimentAnalysisRequest => SentimentAnalysisRequest.validate(o) === true,
    parse: (o: unknown): { right: SentimentAnalysisRequest } | { left: DefinedError[] } => 
    {
        if(SentimentAnalysisRequest.is(o)) {
            return { right: o }
        }
        return { left: (SentimentAnalysisRequest.errors ?? []) as DefinedError[] }
    },
} as const


export interface SpamDetectionRequest {
    /**
     * Your API Key
     */
    api_key: string
    /**
     * The text that you want to analyze. It should not contain HTML tags.
     */
    text?: (string | undefined)
}

export const SpamDetectionRequest = {
    validate: SpamDetectionRequestValidator as ValidateFunction<SpamDetectionRequest>,
    get schema() { return SpamDetectionRequest.validate.schema},
    get errors() { return SpamDetectionRequest.validate.errors ?? undefined },
    is: (o: unknown): o is SpamDetectionRequest => SpamDetectionRequest.validate(o) === true,
    parse: (o: unknown): { right: SpamDetectionRequest } | { left: DefinedError[] } => 
    {
        if(SpamDetectionRequest.is(o)) {
            return { right: o }
        }
        return { left: (SpamDetectionRequest.errors ?? []) as DefinedError[] }
    },
} as const


export interface SubjectivityAnalysisRequest {
    /**
     * Your API Key
     */
    api_key: string
    /**
     * The text that you want to analyze. It should not contain HTML tags.
     */
    text?: (string | undefined)
}

export const SubjectivityAnalysisRequest = {
    validate: SubjectivityAnalysisRequestValidator as ValidateFunction<SubjectivityAnalysisRequest>,
    get schema() { return SubjectivityAnalysisRequest.validate.schema},
    get errors() { return SubjectivityAnalysisRequest.validate.errors ?? undefined },
    is: (o: unknown): o is SubjectivityAnalysisRequest => SubjectivityAnalysisRequest.validate(o) === true,
    parse: (o: unknown): { right: SubjectivityAnalysisRequest } | { left: DefinedError[] } => 
    {
        if(SubjectivityAnalysisRequest.is(o)) {
            return { right: o }
        }
        return { left: (SubjectivityAnalysisRequest.errors ?? []) as DefinedError[] }
    },
} as const


export interface TextExtractionRequest {
    /**
     * Your API Key
     */
    api_key: string
    /**
     * The HTML source of the webpage.
     */
    text?: (string | undefined)
}

export const TextExtractionRequest = {
    validate: TextExtractionRequestValidator as ValidateFunction<TextExtractionRequest>,
    get schema() { return TextExtractionRequest.validate.schema},
    get errors() { return TextExtractionRequest.validate.errors ?? undefined },
    is: (o: unknown): o is TextExtractionRequest => TextExtractionRequest.validate(o) === true,
    parse: (o: unknown): { right: TextExtractionRequest } | { left: DefinedError[] } => 
    {
        if(TextExtractionRequest.is(o)) {
            return { right: o }
        }
        return { left: (TextExtractionRequest.errors ?? []) as DefinedError[] }
    },
} as const


export interface TopicClassificationRequest {
    /**
     * Your API Key
     */
    api_key: string
    /**
     * The text that you want to analyze. It should not contain HTML tags.
     */
    text?: (string | undefined)
}

export const TopicClassificationRequest = {
    validate: TopicClassificationRequestValidator as ValidateFunction<TopicClassificationRequest>,
    get schema() { return TopicClassificationRequest.validate.schema},
    get errors() { return TopicClassificationRequest.validate.errors ?? undefined },
    is: (o: unknown): o is TopicClassificationRequest => TopicClassificationRequest.validate(o) === true,
    parse: (o: unknown): { right: TopicClassificationRequest } | { left: DefinedError[] } => 
    {
        if(TopicClassificationRequest.is(o)) {
            return { right: o }
        }
        return { left: (TopicClassificationRequest.errors ?? []) as DefinedError[] }
    },
} as const


export interface TwitterSentimentAnalysisRequest {
    /**
     * Your API Key
     */
    api_key: string
    /**
     * The text of the tweet that we evaluate.
     */
    text?: (string | undefined)
}

export const TwitterSentimentAnalysisRequest = {
    validate: TwitterSentimentAnalysisRequestValidator as ValidateFunction<TwitterSentimentAnalysisRequest>,
    get schema() { return TwitterSentimentAnalysisRequest.validate.schema},
    get errors() { return TwitterSentimentAnalysisRequest.validate.errors ?? undefined },
    is: (o: unknown): o is TwitterSentimentAnalysisRequest => TwitterSentimentAnalysisRequest.validate(o) === true,
    parse: (o: unknown): { right: TwitterSentimentAnalysisRequest } | { left: DefinedError[] } => 
    {
        if(TwitterSentimentAnalysisRequest.is(o)) {
            return { right: o }
        }
        return { left: (TwitterSentimentAnalysisRequest.errors ?? []) as DefinedError[] }
    },
} as const


",
    "examples/restclients/ajv/datumbox/schemas/adult-content-detection-request.schema.js": "/* eslint-disable */
// @ts-nocheck
/**
 * Generated by Ajv https://ajv.js.org/guide/managing-schemas.html#standalone-validation-code
 */
"use strict";
/** @type {unknown} */
export const validate = validate10;export default validate10;const schema11 = {"$schema":"http://json-schema.org/draft-07/schema#","title":"AdultContentDetectionRequest","type":"object","properties":{"api_key":{"type":"string","description":"Your API Key"},"text":{"type":"string","description":"The text that you want to analyze. It should not contain HTML tags."}},"required":["api_key"],"additionalProperties":true};function validate10(data, {instancePath="", parentData, parentDataProperty, rootData=data}={}){let vErrors = null;let errors = 0;if(errors === 0){if(data && typeof data == "object" && !Array.isArray(data)){let missing0;if((data.api_key === undefined) && (missing0 = "api_key")){validate10.errors = [{instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: missing0},message:"must have required property '"+missing0+"'"}];return false;}else {if(data.api_key !== undefined){const _errs2 = errors;if(typeof data.api_key !== "string"){validate10.errors = [{instancePath:instancePath+"/api_key",schemaPath:"#/properties/api_key/type",keyword:"type",params:{type: "string"},message:"must be string"}];return false;}var valid0 = _errs2 === errors;}else {var valid0 = true;}if(valid0){if(data.text !== undefined){const _errs4 = errors;if(typeof data.text !== "string"){validate10.errors = [{instancePath:instancePath+"/text",schemaPath:"#/properties/text/type",keyword:"type",params:{type: "string"},message:"must be string"}];return false;}var valid0 = _errs4 === errors;}else {var valid0 = true;}}}}else {validate10.errors = [{instancePath,schemaPath:"#/type",keyword:"type",params:{type: "object"},message:"must be object"}];return false;}}validate10.errors = vErrors;return errors === 0;};validate.schema=schema11;",
    "examples/restclients/ajv/datumbox/schemas/commercial-detection-request.schema.js": "/* eslint-disable */
// @ts-nocheck
/**
 * Generated by Ajv https://ajv.js.org/guide/managing-schemas.html#standalone-validation-code
 */
"use strict";
/** @type {unknown} */
export const validate = validate10;export default validate10;const schema11 = {"$schema":"http://json-schema.org/draft-07/schema#","title":"CommercialDetectionRequest","type":"object","properties":{"api_key":{"type":"string","description":"Your API Key"},"text":{"type":"string","description":"The text that you want to analyze. It should not contain HTML tags."}},"required":["api_key"],"additionalProperties":true};function validate10(data, {instancePath="", parentData, parentDataProperty, rootData=data}={}){let vErrors = null;let errors = 0;if(errors === 0){if(data && typeof data == "object" && !Array.isArray(data)){let missing0;if((data.api_key === undefined) && (missing0 = "api_key")){validate10.errors = [{instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: missing0},message:"must have required property '"+missing0+"'"}];return false;}else {if(data.api_key !== undefined){const _errs2 = errors;if(typeof data.api_key !== "string"){validate10.errors = [{instancePath:instancePath+"/api_key",schemaPath:"#/properties/api_key/type",keyword:"type",params:{type: "string"},message:"must be string"}];return false;}var valid0 = _errs2 === errors;}else {var valid0 = true;}if(valid0){if(data.text !== undefined){const _errs4 = errors;if(typeof data.text !== "string"){validate10.errors = [{instancePath:instancePath+"/text",schemaPath:"#/properties/text/type",keyword:"type",params:{type: "string"},message:"must be string"}];return false;}var valid0 = _errs4 === errors;}else {var valid0 = true;}}}}else {validate10.errors = [{instancePath,schemaPath:"#/type",keyword:"type",params:{type: "object"},message:"must be object"}];return false;}}validate10.errors = vErrors;return errors === 0;};validate.schema=schema11;",
    "examples/restclients/ajv/datumbox/schemas/document-similarity-request.schema.js": "/* eslint-disable */
// @ts-nocheck
/**
 * Generated by Ajv https://ajv.js.org/guide/managing-schemas.html#standalone-validation-code
 */
"use strict";
/** @type {unknown} */
export const validate = validate10;export default validate10;const schema11 = {"$schema":"http://json-schema.org/draft-07/schema#","title":"DocumentSimilarityRequest","type":"object","properties":{"api_key":{"type":"string","description":"Your API Key"},"copy":{"type":"string","description":"The second text. It should not contain HTML tags."},"original":{"type":"string","description":"The first text. It should not contain HTML tags."}},"required":["api_key"],"additionalProperties":true};function validate10(data, {instancePath="", parentData, parentDataProperty, rootData=data}={}){let vErrors = null;let errors = 0;if(errors === 0){if(data && typeof data == "object" && !Array.isArray(data)){let missing0;if((data.api_key === undefined) && (missing0 = "api_key")){validate10.errors = [{instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: missing0},message:"must have required property '"+missing0+"'"}];return false;}else {if(data.api_key !== undefined){const _errs2 = errors;if(typeof data.api_key !== "string"){validate10.errors = [{instancePath:instancePath+"/api_key",schemaPath:"#/properties/api_key/type",keyword:"type",params:{type: "string"},message:"must be string"}];return false;}var valid0 = _errs2 === errors;}else {var valid0 = true;}if(valid0){if(data.copy !== undefined){const _errs4 = errors;if(typeof data.copy !== "string"){validate10.errors = [{instancePath:instancePath+"/copy",schemaPath:"#/properties/copy/type",keyword:"type",params:{type: "string"},message:"must be string"}];return false;}var valid0 = _errs4 === errors;}else {var valid0 = true;}if(valid0){if(data.original !== undefined){const _errs6 = errors;if(typeof data.original !== "string"){validate10.errors = [{instancePath:instancePath+"/original",schemaPath:"#/properties/original/type",keyword:"type",params:{type: "string"},message:"must be string"}];return false;}var valid0 = _errs6 === errors;}else {var valid0 = true;}}}}}else {validate10.errors = [{instancePath,schemaPath:"#/type",keyword:"type",params:{type: "object"},message:"must be object"}];return false;}}validate10.errors = vErrors;return errors === 0;};validate.schema=schema11;",
    "examples/restclients/ajv/datumbox/schemas/educational-detection-request.schema.js": "/* eslint-disable */
// @ts-nocheck
/**
 * Generated by Ajv https://ajv.js.org/guide/managing-schemas.html#standalone-validation-code
 */
"use strict";
/** @type {unknown} */
export const validate = validate10;export default validate10;const schema11 = {"$schema":"http://json-schema.org/draft-07/schema#","title":"EducationalDetectionRequest","type":"object","properties":{"api_key":{"type":"string","description":"Your API Key"},"text":{"type":"string","description":"The text that you want to analyze. It should not contain HTML tags."}},"required":["api_key"],"additionalProperties":true};function validate10(data, {instancePath="", parentData, parentDataProperty, rootData=data}={}){let vErrors = null;let errors = 0;if(errors === 0){if(data && typeof data == "object" && !Array.isArray(data)){let missing0;if((data.api_key === undefined) && (missing0 = "api_key")){validate10.errors = [{instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: missing0},message:"must have required property '"+missing0+"'"}];return false;}else {if(data.api_key !== undefined){const _errs2 = errors;if(typeof data.api_key !== "string"){validate10.errors = [{instancePath:instancePath+"/api_key",schemaPath:"#/properties/api_key/type",keyword:"type",params:{type: "string"},message:"must be string"}];return false;}var valid0 = _errs2 === errors;}else {var valid0 = true;}if(valid0){if(data.text !== undefined){const _errs4 = errors;if(typeof data.text !== "string"){validate10.errors = [{instancePath:instancePath+"/text",schemaPath:"#/properties/text/type",keyword:"type",params:{type: "string"},message:"must be string"}];return false;}var valid0 = _errs4 === errors;}else {var valid0 = true;}}}}else {validate10.errors = [{instancePath,schemaPath:"#/type",keyword:"type",params:{type: "object"},message:"must be object"}];return false;}}validate10.errors = vErrors;return errors === 0;};validate.schema=schema11;",
    "examples/restclients/ajv/datumbox/schemas/gender-detection-request.schema.js": "/* eslint-disable */
// @ts-nocheck
/**
 * Generated by Ajv https://ajv.js.org/guide/managing-schemas.html#standalone-validation-code
 */
"use strict";
/** @type {unknown} */
export const validate = validate10;export default validate10;const schema11 = {"$schema":"http://json-schema.org/draft-07/schema#","title":"GenderDetectionRequest","type":"object","properties":{"api_key":{"type":"string","description":"Your API Key"},"text":{"type":"string","description":"The text that you want to analyze. It should not contain HTML tags."}},"required":["api_key"],"additionalProperties":true};function validate10(data, {instancePath="", parentData, parentDataProperty, rootData=data}={}){let vErrors = null;let errors = 0;if(errors === 0){if(data && typeof data == "object" && !Array.isArray(data)){let missing0;if((data.api_key === undefined) && (missing0 = "api_key")){validate10.errors = [{instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: missing0},message:"must have required property '"+missing0+"'"}];return false;}else {if(data.api_key !== undefined){const _errs2 = errors;if(typeof data.api_key !== "string"){validate10.errors = [{instancePath:instancePath+"/api_key",schemaPath:"#/properties/api_key/type",keyword:"type",params:{type: "string"},message:"must be string"}];return false;}var valid0 = _errs2 === errors;}else {var valid0 = true;}if(valid0){if(data.text !== undefined){const _errs4 = errors;if(typeof data.text !== "string"){validate10.errors = [{instancePath:instancePath+"/text",schemaPath:"#/properties/text/type",keyword:"type",params:{type: "string"},message:"must be string"}];return false;}var valid0 = _errs4 === errors;}else {var valid0 = true;}}}}else {validate10.errors = [{instancePath,schemaPath:"#/type",keyword:"type",params:{type: "object"},message:"must be object"}];return false;}}validate10.errors = vErrors;return errors === 0;};validate.schema=schema11;",
    "examples/restclients/ajv/datumbox/schemas/keyword-extraction-request.schema.js": "/* eslint-disable */
// @ts-nocheck
/**
 * Generated by Ajv https://ajv.js.org/guide/managing-schemas.html#standalone-validation-code
 */
"use strict";
/** @type {unknown} */
export const validate = validate10;export default validate10;const schema11 = {"$schema":"http://json-schema.org/draft-07/schema#","title":"KeywordExtractionRequest","type":"object","properties":{"api_key":{"type":"string","description":"Your API Key"},"n":{"type":"integer","description":"The number of keyword combinations (n-grams) that you wish to extract.","minimum":1,"maximum":5},"text":{"type":"string","description":"The text that you want to analyze. It should not contain HTML tags."}},"required":["api_key"],"additionalProperties":true};function validate10(data, {instancePath="", parentData, parentDataProperty, rootData=data}={}){let vErrors = null;let errors = 0;if(errors === 0){if(data && typeof data == "object" && !Array.isArray(data)){let missing0;if((data.api_key === undefined) && (missing0 = "api_key")){validate10.errors = [{instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: missing0},message:"must have required property '"+missing0+"'"}];return false;}else {if(data.api_key !== undefined){const _errs2 = errors;if(typeof data.api_key !== "string"){validate10.errors = [{instancePath:instancePath+"/api_key",schemaPath:"#/properties/api_key/type",keyword:"type",params:{type: "string"},message:"must be string"}];return false;}var valid0 = _errs2 === errors;}else {var valid0 = true;}if(valid0){if(data.n !== undefined){let data1 = data.n;const _errs4 = errors;if(!(((typeof data1 == "number") && (!(data1 % 1) && !isNaN(data1))) && (isFinite(data1)))){validate10.errors = [{instancePath:instancePath+"/n",schemaPath:"#/properties/n/type",keyword:"type",params:{type: "integer"},message:"must be integer"}];return false;}if(errors === _errs4){if((typeof data1 == "number") && (isFinite(data1))){if(data1 > 5 || isNaN(data1)){validate10.errors = [{instancePath:instancePath+"/n",schemaPath:"#/properties/n/maximum",keyword:"maximum",params:{comparison: "<=", limit: 5},message:"must be <= 5"}];return false;}else {if(data1 < 1 || isNaN(data1)){validate10.errors = [{instancePath:instancePath+"/n",schemaPath:"#/properties/n/minimum",keyword:"minimum",params:{comparison: ">=", limit: 1},message:"must be >= 1"}];return false;}}}}var valid0 = _errs4 === errors;}else {var valid0 = true;}if(valid0){if(data.text !== undefined){const _errs6 = errors;if(typeof data.text !== "string"){validate10.errors = [{instancePath:instancePath+"/text",schemaPath:"#/properties/text/type",keyword:"type",params:{type: "string"},message:"must be string"}];return false;}var valid0 = _errs6 === errors;}else {var valid0 = true;}}}}}else {validate10.errors = [{instancePath,schemaPath:"#/type",keyword:"type",params:{type: "object"},message:"must be object"}];return false;}}validate10.errors = vErrors;return errors === 0;};validate.schema=schema11;",
    "examples/restclients/ajv/datumbox/schemas/language-detection-request.schema.js": "/* eslint-disable */
// @ts-nocheck
/**
 * Generated by Ajv https://ajv.js.org/guide/managing-schemas.html#standalone-validation-code
 */
"use strict";
/** @type {unknown} */
export const validate = validate10;export default validate10;const schema11 = {"$schema":"http://json-schema.org/draft-07/schema#","title":"LanguageDetectionRequest","type":"object","properties":{"api_key":{"type":"string","description":"Your API Key"},"text":{"type":"string","description":"The text that you want to analyze. It should not contain HTML tags."}},"required":["api_key"],"additionalProperties":true};function validate10(data, {instancePath="", parentData, parentDataProperty, rootData=data}={}){let vErrors = null;let errors = 0;if(errors === 0){if(data && typeof data == "object" && !Array.isArray(data)){let missing0;if((data.api_key === undefined) && (missing0 = "api_key")){validate10.errors = [{instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: missing0},message:"must have required property '"+missing0+"'"}];return false;}else {if(data.api_key !== undefined){const _errs2 = errors;if(typeof data.api_key !== "string"){validate10.errors = [{instancePath:instancePath+"/api_key",schemaPath:"#/properties/api_key/type",keyword:"type",params:{type: "string"},message:"must be string"}];return false;}var valid0 = _errs2 === errors;}else {var valid0 = true;}if(valid0){if(data.text !== undefined){const _errs4 = errors;if(typeof data.text !== "string"){validate10.errors = [{instancePath:instancePath+"/text",schemaPath:"#/properties/text/type",keyword:"type",params:{type: "string"},message:"must be string"}];return false;}var valid0 = _errs4 === errors;}else {var valid0 = true;}}}}else {validate10.errors = [{instancePath,schemaPath:"#/type",keyword:"type",params:{type: "object"},message:"must be object"}];return false;}}validate10.errors = vErrors;return errors === 0;};validate.schema=schema11;",
    "examples/restclients/ajv/datumbox/schemas/readability-assessment-request.schema.js": "/* eslint-disable */
// @ts-nocheck
/**
 * Generated by Ajv https://ajv.js.org/guide/managing-schemas.html#standalone-validation-code
 */
"use strict";
/** @type {unknown} */
export const validate = validate10;export default validate10;const schema11 = {"$schema":"http://json-schema.org/draft-07/schema#","title":"ReadabilityAssessmentRequest","type":"object","properties":{"api_key":{"type":"string","description":"Your API Key"},"text":{"type":"string","description":"The text that you want to analyze. It should not contain HTML tags."}},"required":["api_key"],"additionalProperties":true};function validate10(data, {instancePath="", parentData, parentDataProperty, rootData=data}={}){let vErrors = null;let errors = 0;if(errors === 0){if(data && typeof data == "object" && !Array.isArray(data)){let missing0;if((data.api_key === undefined) && (missing0 = "api_key")){validate10.errors = [{instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: missing0},message:"must have required property '"+missing0+"'"}];return false;}else {if(data.api_key !== undefined){const _errs2 = errors;if(typeof data.api_key !== "string"){validate10.errors = [{instancePath:instancePath+"/api_key",schemaPath:"#/properties/api_key/type",keyword:"type",params:{type: "string"},message:"must be string"}];return false;}var valid0 = _errs2 === errors;}else {var valid0 = true;}if(valid0){if(data.text !== undefined){const _errs4 = errors;if(typeof data.text !== "string"){validate10.errors = [{instancePath:instancePath+"/text",schemaPath:"#/properties/text/type",keyword:"type",params:{type: "string"},message:"must be string"}];return false;}var valid0 = _errs4 === errors;}else {var valid0 = true;}}}}else {validate10.errors = [{instancePath,schemaPath:"#/type",keyword:"type",params:{type: "object"},message:"must be object"}];return false;}}validate10.errors = vErrors;return errors === 0;};validate.schema=schema11;",
    "examples/restclients/ajv/datumbox/schemas/sentiment-analysis-request.schema.js": "/* eslint-disable */
// @ts-nocheck
/**
 * Generated by Ajv https://ajv.js.org/guide/managing-schemas.html#standalone-validation-code
 */
"use strict";
/** @type {unknown} */
export const validate = validate10;export default validate10;const schema11 = {"$schema":"http://json-schema.org/draft-07/schema#","title":"SentimentAnalysisRequest","type":"object","properties":{"api_key":{"type":"string","description":"Your API Key"},"text":{"type":"string","description":"The text that you want to analyze. It should not contain HTML tags."}},"required":["api_key"],"additionalProperties":true};function validate10(data, {instancePath="", parentData, parentDataProperty, rootData=data}={}){let vErrors = null;let errors = 0;if(errors === 0){if(data && typeof data == "object" && !Array.isArray(data)){let missing0;if((data.api_key === undefined) && (missing0 = "api_key")){validate10.errors = [{instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: missing0},message:"must have required property '"+missing0+"'"}];return false;}else {if(data.api_key !== undefined){const _errs2 = errors;if(typeof data.api_key !== "string"){validate10.errors = [{instancePath:instancePath+"/api_key",schemaPath:"#/properties/api_key/type",keyword:"type",params:{type: "string"},message:"must be string"}];return false;}var valid0 = _errs2 === errors;}else {var valid0 = true;}if(valid0){if(data.text !== undefined){const _errs4 = errors;if(typeof data.text !== "string"){validate10.errors = [{instancePath:instancePath+"/text",schemaPath:"#/properties/text/type",keyword:"type",params:{type: "string"},message:"must be string"}];return false;}var valid0 = _errs4 === errors;}else {var valid0 = true;}}}}else {validate10.errors = [{instancePath,schemaPath:"#/type",keyword:"type",params:{type: "object"},message:"must be object"}];return false;}}validate10.errors = vErrors;return errors === 0;};validate.schema=schema11;",
    "examples/restclients/ajv/datumbox/schemas/spam-detection-request.schema.js": "/* eslint-disable */
// @ts-nocheck
/**
 * Generated by Ajv https://ajv.js.org/guide/managing-schemas.html#standalone-validation-code
 */
"use strict";
/** @type {unknown} */
export const validate = validate10;export default validate10;const schema11 = {"$schema":"http://json-schema.org/draft-07/schema#","title":"SpamDetectionRequest","type":"object","properties":{"api_key":{"type":"string","description":"Your API Key"},"text":{"type":"string","description":"The text that you want to analyze. It should not contain HTML tags."}},"required":["api_key"],"additionalProperties":true};function validate10(data, {instancePath="", parentData, parentDataProperty, rootData=data}={}){let vErrors = null;let errors = 0;if(errors === 0){if(data && typeof data == "object" && !Array.isArray(data)){let missing0;if((data.api_key === undefined) && (missing0 = "api_key")){validate10.errors = [{instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: missing0},message:"must have required property '"+missing0+"'"}];return false;}else {if(data.api_key !== undefined){const _errs2 = errors;if(typeof data.api_key !== "string"){validate10.errors = [{instancePath:instancePath+"/api_key",schemaPath:"#/properties/api_key/type",keyword:"type",params:{type: "string"},message:"must be string"}];return false;}var valid0 = _errs2 === errors;}else {var valid0 = true;}if(valid0){if(data.text !== undefined){const _errs4 = errors;if(typeof data.text !== "string"){validate10.errors = [{instancePath:instancePath+"/text",schemaPath:"#/properties/text/type",keyword:"type",params:{type: "string"},message:"must be string"}];return false;}var valid0 = _errs4 === errors;}else {var valid0 = true;}}}}else {validate10.errors = [{instancePath,schemaPath:"#/type",keyword:"type",params:{type: "object"},message:"must be object"}];return false;}}validate10.errors = vErrors;return errors === 0;};validate.schema=schema11;",
    "examples/restclients/ajv/datumbox/schemas/subjectivity-analysis-request.schema.js": "/* eslint-disable */
// @ts-nocheck
/**
 * Generated by Ajv https://ajv.js.org/guide/managing-schemas.html#standalone-validation-code
 */
"use strict";
/** @type {unknown} */
export const validate = validate10;export default validate10;const schema11 = {"$schema":"http://json-schema.org/draft-07/schema#","title":"SubjectivityAnalysisRequest","type":"object","properties":{"api_key":{"type":"string","description":"Your API Key"},"text":{"type":"string","description":"The text that you want to analyze. It should not contain HTML tags."}},"required":["api_key"],"additionalProperties":true};function validate10(data, {instancePath="", parentData, parentDataProperty, rootData=data}={}){let vErrors = null;let errors = 0;if(errors === 0){if(data && typeof data == "object" && !Array.isArray(data)){let missing0;if((data.api_key === undefined) && (missing0 = "api_key")){validate10.errors = [{instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: missing0},message:"must have required property '"+missing0+"'"}];return false;}else {if(data.api_key !== undefined){const _errs2 = errors;if(typeof data.api_key !== "string"){validate10.errors = [{instancePath:instancePath+"/api_key",schemaPath:"#/properties/api_key/type",keyword:"type",params:{type: "string"},message:"must be string"}];return false;}var valid0 = _errs2 === errors;}else {var valid0 = true;}if(valid0){if(data.text !== undefined){const _errs4 = errors;if(typeof data.text !== "string"){validate10.errors = [{instancePath:instancePath+"/text",schemaPath:"#/properties/text/type",keyword:"type",params:{type: "string"},message:"must be string"}];return false;}var valid0 = _errs4 === errors;}else {var valid0 = true;}}}}else {validate10.errors = [{instancePath,schemaPath:"#/type",keyword:"type",params:{type: "object"},message:"must be object"}];return false;}}validate10.errors = vErrors;return errors === 0;};validate.schema=schema11;",
    "examples/restclients/ajv/datumbox/schemas/text-extraction-request.schema.js": "/* eslint-disable */
// @ts-nocheck
/**
 * Generated by Ajv https://ajv.js.org/guide/managing-schemas.html#standalone-validation-code
 */
"use strict";
/** @type {unknown} */
export const validate = validate10;export default validate10;const schema11 = {"$schema":"http://json-schema.org/draft-07/schema#","title":"TextExtractionRequest","type":"object","properties":{"api_key":{"type":"string","description":"Your API Key"},"text":{"type":"string","description":"The HTML source of the webpage."}},"required":["api_key"],"additionalProperties":true};function validate10(data, {instancePath="", parentData, parentDataProperty, rootData=data}={}){let vErrors = null;let errors = 0;if(errors === 0){if(data && typeof data == "object" && !Array.isArray(data)){let missing0;if((data.api_key === undefined) && (missing0 = "api_key")){validate10.errors = [{instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: missing0},message:"must have required property '"+missing0+"'"}];return false;}else {if(data.api_key !== undefined){const _errs2 = errors;if(typeof data.api_key !== "string"){validate10.errors = [{instancePath:instancePath+"/api_key",schemaPath:"#/properties/api_key/type",keyword:"type",params:{type: "string"},message:"must be string"}];return false;}var valid0 = _errs2 === errors;}else {var valid0 = true;}if(valid0){if(data.text !== undefined){const _errs4 = errors;if(typeof data.text !== "string"){validate10.errors = [{instancePath:instancePath+"/text",schemaPath:"#/properties/text/type",keyword:"type",params:{type: "string"},message:"must be string"}];return false;}var valid0 = _errs4 === errors;}else {var valid0 = true;}}}}else {validate10.errors = [{instancePath,schemaPath:"#/type",keyword:"type",params:{type: "object"},message:"must be object"}];return false;}}validate10.errors = vErrors;return errors === 0;};validate.schema=schema11;",
    "examples/restclients/ajv/datumbox/schemas/topic-classification-request.schema.js": "/* eslint-disable */
// @ts-nocheck
/**
 * Generated by Ajv https://ajv.js.org/guide/managing-schemas.html#standalone-validation-code
 */
"use strict";
/** @type {unknown} */
export const validate = validate10;export default validate10;const schema11 = {"$schema":"http://json-schema.org/draft-07/schema#","title":"TopicClassificationRequest","type":"object","properties":{"api_key":{"type":"string","description":"Your API Key"},"text":{"type":"string","description":"The text that you want to analyze. It should not contain HTML tags."}},"required":["api_key"],"additionalProperties":true};function validate10(data, {instancePath="", parentData, parentDataProperty, rootData=data}={}){let vErrors = null;let errors = 0;if(errors === 0){if(data && typeof data == "object" && !Array.isArray(data)){let missing0;if((data.api_key === undefined) && (missing0 = "api_key")){validate10.errors = [{instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: missing0},message:"must have required property '"+missing0+"'"}];return false;}else {if(data.api_key !== undefined){const _errs2 = errors;if(typeof data.api_key !== "string"){validate10.errors = [{instancePath:instancePath+"/api_key",schemaPath:"#/properties/api_key/type",keyword:"type",params:{type: "string"},message:"must be string"}];return false;}var valid0 = _errs2 === errors;}else {var valid0 = true;}if(valid0){if(data.text !== undefined){const _errs4 = errors;if(typeof data.text !== "string"){validate10.errors = [{instancePath:instancePath+"/text",schemaPath:"#/properties/text/type",keyword:"type",params:{type: "string"},message:"must be string"}];return false;}var valid0 = _errs4 === errors;}else {var valid0 = true;}}}}else {validate10.errors = [{instancePath,schemaPath:"#/type",keyword:"type",params:{type: "object"},message:"must be object"}];return false;}}validate10.errors = vErrors;return errors === 0;};validate.schema=schema11;",
    "examples/restclients/ajv/datumbox/schemas/twitter-sentiment-analysis-request.schema.js": "/* eslint-disable */
// @ts-nocheck
/**
 * Generated by Ajv https://ajv.js.org/guide/managing-schemas.html#standalone-validation-code
 */
"use strict";
/** @type {unknown} */
export const validate = validate10;export default validate10;const schema11 = {"$schema":"http://json-schema.org/draft-07/schema#","title":"TwitterSentimentAnalysisRequest","type":"object","properties":{"api_key":{"type":"string","description":"Your API Key"},"text":{"type":"string","description":"The text of the tweet that we evaluate."}},"required":["api_key"],"additionalProperties":true};function validate10(data, {instancePath="", parentData, parentDataProperty, rootData=data}={}){let vErrors = null;let errors = 0;if(errors === 0){if(data && typeof data == "object" && !Array.isArray(data)){let missing0;if((data.api_key === undefined) && (missing0 = "api_key")){validate10.errors = [{instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: missing0},message:"must have required property '"+missing0+"'"}];return false;}else {if(data.api_key !== undefined){const _errs2 = errors;if(typeof data.api_key !== "string"){validate10.errors = [{instancePath:instancePath+"/api_key",schemaPath:"#/properties/api_key/type",keyword:"type",params:{type: "string"},message:"must be string"}];return false;}var valid0 = _errs2 === errors;}else {var valid0 = true;}if(valid0){if(data.text !== undefined){const _errs4 = errors;if(typeof data.text !== "string"){validate10.errors = [{instancePath:instancePath+"/text",schemaPath:"#/properties/text/type",keyword:"type",params:{type: "string"},message:"must be string"}];return false;}var valid0 = _errs4 === errors;}else {var valid0 = true;}}}}else {validate10.errors = [{instancePath,schemaPath:"#/type",keyword:"type",params:{type: "object"},message:"must be object"}];return false;}}validate10.errors = vErrors;return errors === 0;};validate.schema=schema11;",
  },
}
`;

exports[`output generation - zod 1`] = `
{
  "cleanFn": [Function],
  "outputFiles": {
    "examples/restclients/zod/datumbox/datumbox.client.ts": "/**
* Generated by @skyleague/therefore
* Do not manually touch this
*/
// biome-ignore-all lint: this file is generated
/* eslint-disable */

import type { IncomingHttpHeaders } from 'node:http'

import { got } from 'got'
import type { CancelableRequest, Got, Options, OptionsInit, Response } from 'got'
import type { SafeParseReturnType, ZodError } from 'zod'

import { AdultContentDetectionRequest, CommercialDetectionRequest, DocumentSimilarityRequest, EducationalDetectionRequest, GenderDetectionRequest, KeywordExtractionRequest, LanguageDetectionRequest, ReadabilityAssessmentRequest, SentimentAnalysisRequest, SpamDetectionRequest, SubjectivityAnalysisRequest, TextExtractionRequest, TopicClassificationRequest, TwitterSentimentAnalysisRequest } from './datumbox.zod.js'

/**
 * api.datumbox.com
 * 
 * Datumbox offers a Machine Learning platform composed of 14 classifiers and Natural Language processing functions. Functions include sentiment analysis, topic classification, readability assessment, language detection, and much more.
 */
export class Datumbox {
    public client: Got

    public constructor(
    {
        prefixUrl = 'http://api.datumbox.com/',
        options,
        client = got
    }: {
        prefixUrl?: string | 'http://api.datumbox.com/',
        options?: Options | OptionsInit,
        client?: Got
    } = {}) {
        this.client = client.extend(...[{ prefixUrl, throwHttpErrors: false }, options].filter((o): o is Options => o !== undefined))
    }


    /**
     * POST /1.0/AdultContentDetection.json
     * 
     * Classifies the Document as adult or noadult
     * 
     * The Adult Content Detection function classifies the documents as adult or noadult based on their context. It can be used to detect whether a document contains content unsuitable for minors.
     */
    public adultContentDetection({body}: {body: AdultContentDetectionRequest}): Promise<
    | SuccessResponse<'200', unknown>
    | FailureResponse<undefined, unknown, 'request:body', undefined>
    | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
    | FailureResponse<StatusCode<1 | 3 | 4 | 5>, string, 'response:statuscode', IncomingHttpHeaders>
    >
    {
        const _body = this.validateRequestBody(AdultContentDetectionRequest, body)
        if ('left' in _body) {
        return Promise.resolve(_body)
        }


        return this.awaitResponse(this.client.post('1.0/AdultContentDetection.json', {
            form: _body.right,responseType: 'text',
        }), {
            200: { safeParse: (x: unknown) => ({ success: true, data: x }) },
        }) as ReturnType<this["adultContentDetection"]>
    }

    /**
     * POST /1.0/CommercialDetection.json
     * 
     * Classifies the Document as commercial or nocommercial
     * 
     * The Commercial Detection function labels the documents as commercial or non-commercial based on their keywords and expressions. It can be used to detect whether a website is commercial or not.
     */
    public commercialDetection({body}: {body: CommercialDetectionRequest}): Promise<
    | SuccessResponse<'200', unknown>
    | FailureResponse<undefined, unknown, 'request:body', undefined>
    | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
    | FailureResponse<StatusCode<1 | 3 | 4 | 5>, string, 'response:statuscode', IncomingHttpHeaders>
    >
    {
        const _body = this.validateRequestBody(CommercialDetectionRequest, body)
        if ('left' in _body) {
        return Promise.resolve(_body)
        }


        return this.awaitResponse(this.client.post('1.0/CommercialDetection.json', {
            form: _body.right,responseType: 'text',
        }), {
            200: { safeParse: (x: unknown) => ({ success: true, data: x }) },
        }) as ReturnType<this["commercialDetection"]>
    }

    /**
     * POST /1.0/DocumentSimilarity.json
     * 
     * Estimates the similarity between 2 Documents
     * 
     * The Document Similarity function estimates the degree of similarity between two documents. It can be used to detect duplicate webpages or detect plagiarism.
     */
    public documentSimilarity({body}: {body: DocumentSimilarityRequest}): Promise<
    | SuccessResponse<'200', unknown>
    | FailureResponse<undefined, unknown, 'request:body', undefined>
    | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
    | FailureResponse<StatusCode<1 | 3 | 4 | 5>, string, 'response:statuscode', IncomingHttpHeaders>
    >
    {
        const _body = this.validateRequestBody(DocumentSimilarityRequest, body)
        if ('left' in _body) {
        return Promise.resolve(_body)
        }


        return this.awaitResponse(this.client.post('1.0/DocumentSimilarity.json', {
            form: _body.right,responseType: 'text',
        }), {
            200: { safeParse: (x: unknown) => ({ success: true, data: x }) },
        }) as ReturnType<this["documentSimilarity"]>
    }

    /**
     * POST /1.0/EducationalDetection.json
     * 
     * Classifies the Document as educational or noeducational
     * 
     * The Educational Detection function classifies the documents as educational or non-educational based on their context. It can be used to detect whether a website is educational or not.
     */
    public educationalDetection({body}: {body: EducationalDetectionRequest}): Promise<
    | SuccessResponse<'200', unknown>
    | FailureResponse<undefined, unknown, 'request:body', undefined>
    | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
    | FailureResponse<StatusCode<1 | 3 | 4 | 5>, string, 'response:statuscode', IncomingHttpHeaders>
    >
    {
        const _body = this.validateRequestBody(EducationalDetectionRequest, body)
        if ('left' in _body) {
        return Promise.resolve(_body)
        }


        return this.awaitResponse(this.client.post('1.0/EducationalDetection.json', {
            form: _body.right,responseType: 'text',
        }), {
            200: { safeParse: (x: unknown) => ({ success: true, data: x }) },
        }) as ReturnType<this["educationalDetection"]>
    }

    /**
     * POST /1.0/GenderDetection.json
     * 
     * Gender Detection Service
     * 
     * The Gender Detection function identifies if a particular document is written-by or targets-to a man or a woman based on the context, the words and the idioms found in the text.
     */
    public genderDetection({body}: {body: GenderDetectionRequest}): Promise<
    | SuccessResponse<'200', unknown>
    | FailureResponse<undefined, unknown, 'request:body', undefined>
    | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
    | FailureResponse<StatusCode<1 | 3 | 4 | 5>, string, 'response:statuscode', IncomingHttpHeaders>
    >
    {
        const _body = this.validateRequestBody(GenderDetectionRequest, body)
        if ('left' in _body) {
        return Promise.resolve(_body)
        }


        return this.awaitResponse(this.client.post('1.0/GenderDetection.json', {
            form: _body.right,responseType: 'text',
        }), {
            200: { safeParse: (x: unknown) => ({ success: true, data: x }) },
        }) as ReturnType<this["genderDetection"]>
    }

    /**
     * POST /1.0/KeywordExtraction.json
     * 
     * Extracts the Keywords of the Document
     * 
     * The Keyword Extraction function enables you to extract from an arbitrary document all the keywords and word-combinations along with their occurrences in the text.
     */
    public keywordExtraction({body}: {body: KeywordExtractionRequest}): Promise<
    | SuccessResponse<'200', unknown>
    | FailureResponse<undefined, unknown, 'request:body', undefined>
    | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
    | FailureResponse<StatusCode<1 | 3 | 4 | 5>, string, 'response:statuscode', IncomingHttpHeaders>
    >
    {
        const _body = this.validateRequestBody(KeywordExtractionRequest, body)
        if ('left' in _body) {
        return Promise.resolve(_body)
        }


        return this.awaitResponse(this.client.post('1.0/KeywordExtraction.json', {
            form: _body.right,responseType: 'text',
        }), {
            200: { safeParse: (x: unknown) => ({ success: true, data: x }) },
        }) as ReturnType<this["keywordExtraction"]>
    }

    /**
     * POST /1.0/LanguageDetection.json
     * 
     * Identifies the Language of the Document
     * 
     * The Language Detection function identifies the natural language of the given document based on its words and context. This classifier is able to detect 96 different languages.
     */
    public languageDetection({body}: {body: LanguageDetectionRequest}): Promise<
    | SuccessResponse<'200', unknown>
    | FailureResponse<undefined, unknown, 'request:body', undefined>
    | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
    | FailureResponse<StatusCode<1 | 3 | 4 | 5>, string, 'response:statuscode', IncomingHttpHeaders>
    >
    {
        const _body = this.validateRequestBody(LanguageDetectionRequest, body)
        if ('left' in _body) {
        return Promise.resolve(_body)
        }


        return this.awaitResponse(this.client.post('1.0/LanguageDetection.json', {
            form: _body.right,responseType: 'text',
        }), {
            200: { safeParse: (x: unknown) => ({ success: true, data: x }) },
        }) as ReturnType<this["languageDetection"]>
    }

    /**
     * POST /1.0/ReadabilityAssessment.json
     * 
     * Evaluates the Readability of the Document
     * 
     * The Readability Assessment function determines the degree of readability of a document based on its terms and idioms. The texts are classified as basic, intermediate and advanced depending their difficulty.
     */
    public readabilityAssessment({body}: {body: ReadabilityAssessmentRequest}): Promise<
    | SuccessResponse<'200', unknown>
    | FailureResponse<undefined, unknown, 'request:body', undefined>
    | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
    | FailureResponse<StatusCode<1 | 3 | 4 | 5>, string, 'response:statuscode', IncomingHttpHeaders>
    >
    {
        const _body = this.validateRequestBody(ReadabilityAssessmentRequest, body)
        if ('left' in _body) {
        return Promise.resolve(_body)
        }


        return this.awaitResponse(this.client.post('1.0/ReadabilityAssessment.json', {
            form: _body.right,responseType: 'text',
        }), {
            200: { safeParse: (x: unknown) => ({ success: true, data: x }) },
        }) as ReturnType<this["readabilityAssessment"]>
    }

    /**
     * POST /1.0/SentimentAnalysis.json
     * 
     * Identifies the Sentiment of the Document
     * 
     * The Sentiment Analysis function classifies documents as positive, negative or neutral (lack of sentiment) depending on whether they express a positive, negative or neutral opinion.
     */
    public sentimentAnalysis({body}: {body: SentimentAnalysisRequest}): Promise<
    | SuccessResponse<'200', unknown>
    | FailureResponse<undefined, unknown, 'request:body', undefined>
    | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
    | FailureResponse<StatusCode<1 | 3 | 4 | 5>, string, 'response:statuscode', IncomingHttpHeaders>
    >
    {
        const _body = this.validateRequestBody(SentimentAnalysisRequest, body)
        if ('left' in _body) {
        return Promise.resolve(_body)
        }


        return this.awaitResponse(this.client.post('1.0/SentimentAnalysis.json', {
            form: _body.right,responseType: 'text',
        }), {
            200: { safeParse: (x: unknown) => ({ success: true, data: x }) },
        }) as ReturnType<this["sentimentAnalysis"]>
    }

    /**
     * POST /1.0/SpamDetection.json
     * 
     * Classifies the Document as spam or nospam
     * 
     * The Spam Detection function labels documents as spam or nospam by taking into account their context. It can be used to filter out spam emails and comments.
     */
    public spamDetection({body}: {body: SpamDetectionRequest}): Promise<
    | SuccessResponse<'200', unknown>
    | FailureResponse<undefined, unknown, 'request:body', undefined>
    | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
    | FailureResponse<StatusCode<1 | 3 | 4 | 5>, string, 'response:statuscode', IncomingHttpHeaders>
    >
    {
        const _body = this.validateRequestBody(SpamDetectionRequest, body)
        if ('left' in _body) {
        return Promise.resolve(_body)
        }


        return this.awaitResponse(this.client.post('1.0/SpamDetection.json', {
            form: _body.right,responseType: 'text',
        }), {
            200: { safeParse: (x: unknown) => ({ success: true, data: x }) },
        }) as ReturnType<this["spamDetection"]>
    }

    /**
     * POST /1.0/SubjectivityAnalysis.json
     * 
     * Classifies Document as Subjective or Objective
     * 
     * The Subjectivity Analysis function categorizes documents as subjective or objective based on their writing style. Texts that express personal opinions are labeled as subjective and the others as objective.
     */
    public subjectivityAnalysis({body}: {body: SubjectivityAnalysisRequest}): Promise<
    | SuccessResponse<'200', unknown>
    | FailureResponse<undefined, unknown, 'request:body', undefined>
    | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
    | FailureResponse<StatusCode<1 | 3 | 4 | 5>, string, 'response:statuscode', IncomingHttpHeaders>
    >
    {
        const _body = this.validateRequestBody(SubjectivityAnalysisRequest, body)
        if ('left' in _body) {
        return Promise.resolve(_body)
        }


        return this.awaitResponse(this.client.post('1.0/SubjectivityAnalysis.json', {
            form: _body.right,responseType: 'text',
        }), {
            200: { safeParse: (x: unknown) => ({ success: true, data: x }) },
        }) as ReturnType<this["subjectivityAnalysis"]>
    }

    /**
     * POST /1.0/TextExtraction.json
     * 
     * Extracts the clear text from Webpage
     * 
     * The Text Extraction function enables you to extract the important information from a given webpage. Extracting the clear text of the documents is an important step before any other analysis.
     */
    public textExtraction({body}: {body: TextExtractionRequest}): Promise<
    | SuccessResponse<'200', unknown>
    | FailureResponse<undefined, unknown, 'request:body', undefined>
    | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
    | FailureResponse<StatusCode<1 | 3 | 4 | 5>, string, 'response:statuscode', IncomingHttpHeaders>
    >
    {
        const _body = this.validateRequestBody(TextExtractionRequest, body)
        if ('left' in _body) {
        return Promise.resolve(_body)
        }


        return this.awaitResponse(this.client.post('1.0/TextExtraction.json', {
            form: _body.right,responseType: 'text',
        }), {
            200: { safeParse: (x: unknown) => ({ success: true, data: x }) },
        }) as ReturnType<this["textExtraction"]>
    }

    /**
     * POST /1.0/TopicClassification.json
     * 
     * Identifies the Topic of the Document
     * 
     * The Topic Classification function assigns documents in 12 thematic categories based on their keywords, idioms and jargon. It can be used to identify the topic of the texts.
     */
    public topicClassification({body}: {body: TopicClassificationRequest}): Promise<
    | SuccessResponse<'200', unknown>
    | FailureResponse<undefined, unknown, 'request:body', undefined>
    | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
    | FailureResponse<StatusCode<1 | 3 | 4 | 5>, string, 'response:statuscode', IncomingHttpHeaders>
    >
    {
        const _body = this.validateRequestBody(TopicClassificationRequest, body)
        if ('left' in _body) {
        return Promise.resolve(_body)
        }


        return this.awaitResponse(this.client.post('1.0/TopicClassification.json', {
            form: _body.right,responseType: 'text',
        }), {
            200: { safeParse: (x: unknown) => ({ success: true, data: x }) },
        }) as ReturnType<this["topicClassification"]>
    }

    /**
     * POST /1.0/TwitterSentimentAnalysis.json
     * 
     * Identifies the Sentiment of Twitter Messages
     * 
     * The Twitter Sentiment Analysis function allows you to perform Sentiment Analysis on Twitter. It classifies the tweets as positive, negative or neutral depending on their context.
     */
    public twitterSentimentAnalysis({body}: {body: TwitterSentimentAnalysisRequest}): Promise<
    | SuccessResponse<'200', unknown>
    | FailureResponse<undefined, unknown, 'request:body', undefined>
    | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
    | FailureResponse<StatusCode<1 | 3 | 4 | 5>, string, 'response:statuscode', IncomingHttpHeaders>
    >
    {
        const _body = this.validateRequestBody(TwitterSentimentAnalysisRequest, body)
        if ('left' in _body) {
        return Promise.resolve(_body)
        }


        return this.awaitResponse(this.client.post('1.0/TwitterSentimentAnalysis.json', {
            form: _body.right,responseType: 'text',
        }), {
            200: { safeParse: (x: unknown) => ({ success: true, data: x }) },
        }) as ReturnType<this["twitterSentimentAnalysis"]>
    }

    public validateRequestBody<Body>(
    parser: { safeParse: (o: unknown) => SafeParseReturnType<unknown, Body> }, body: unknown )
    : {right: Body } | FailureResponse<undefined, unknown, 'request:body', undefined> {
        const _body = parser.safeParse(body)
        if (!_body.success)
        {
            return {success: false as const, statusCode: undefined, status: undefined, headers: undefined, left: body, error: _body.error, where: 'request:body' } satisfies FailureResponse<undefined, unknown, 'request:body', undefined>
        }
        return {right: _body.data}
    }

    public async awaitResponse<I, S extends Record<PropertyKey, { safeParse: (o: unknown) => SafeParseReturnType<unknown, I> }>>(response: 
    CancelableRequest<NoInfer<Response<I>>>
    , schemas: S) {
        const result = await response
        const status = result.statusCode < 200 ? 'informational' : result.statusCode < 300 ? 'success' : result.statusCode < 400 ? 'redirection' : result.statusCode < 500 ? 'client-error' : 'server-error'
        const validator = schemas[result.statusCode] ?? schemas.default
        const body = validator?.safeParse?.(result.body)
        if (result.statusCode < 200 || result.statusCode >= 300)
        {
            return {success: false as const, statusCode: result.statusCode.toString(), status, headers: result.headers, left: body?.success ? body.data : result.body, error: body !== undefined && !body.success ? body.error : undefined, where: 'response:statuscode' } 
        }
        if (body === undefined || !body.success)
        {
            return {success: body === undefined, statusCode: result.statusCode.toString(), status, headers: result.headers, left: result.body, error: body?.error, where: 'response:body' }
        }
        return {success: true as const, statusCode: result.statusCode.toString(), status, headers: result.headers, right: body.data }
    }
}

export type Status<Major> = Major extends string ? Major extends \`1\${number}\`? 'informational': Major extends \`2\${number}\` ? 'success' : Major extends \`3\${number}\` ? 'redirection' : Major extends \`4\${number}\` ? 'client-error' : 'server-error' : undefined
export interface SuccessResponse<StatusCode extends string, T> { success: true; statusCode: StatusCode; status: Status<StatusCode>; headers: IncomingHttpHeaders; right: T }
export interface FailureResponse<StatusCode = string, T = unknown, Where = never, Headers = IncomingHttpHeaders> {
success: false
statusCode: StatusCode
status: Status<StatusCode>
headers: Headers
error: ZodError<T> | undefined
left: T
where: Where
}
export type StatusCode<Major extends number = 1 | 2 | 3 | 4 | 5> = \`\${Major}\${number}\`



",
    "examples/restclients/zod/datumbox/datumbox.zod.ts": "/**
* Generated by @skyleague/therefore
* Do not manually touch this
*/
// biome-ignore-all lint: this file is generated
/* eslint-disable */

import { z } from 'zod'

export const AdultContentDetectionRequest = z.object({
    api_key: z.string().describe('Your API Key'),
    text: z.string().describe('The text that you want to analyze. It should not contain HTML tags.').optional(),
})

export type AdultContentDetectionRequest = z.infer<typeof AdultContentDetectionRequest>


export const CommercialDetectionRequest = z.object({
    api_key: z.string().describe('Your API Key'),
    text: z.string().describe('The text that you want to analyze. It should not contain HTML tags.').optional(),
})

export type CommercialDetectionRequest = z.infer<typeof CommercialDetectionRequest>


export const DocumentSimilarityRequest = z.object({
    api_key: z.string().describe('Your API Key'),
    copy: z.string().describe('The second text. It should not contain HTML tags.').optional(),
    original: z.string().describe('The first text. It should not contain HTML tags.').optional(),
})

export type DocumentSimilarityRequest = z.infer<typeof DocumentSimilarityRequest>


export const EducationalDetectionRequest = z.object({
    api_key: z.string().describe('Your API Key'),
    text: z.string().describe('The text that you want to analyze. It should not contain HTML tags.').optional(),
})

export type EducationalDetectionRequest = z.infer<typeof EducationalDetectionRequest>


export const GenderDetectionRequest = z.object({
    api_key: z.string().describe('Your API Key'),
    text: z.string().describe('The text that you want to analyze. It should not contain HTML tags.').optional(),
})

export type GenderDetectionRequest = z.infer<typeof GenderDetectionRequest>


export const KeywordExtractionRequest = z.object({
    api_key: z.string().describe('Your API Key'),
    n: z.number().int().gte(1).lte(5).describe('The number of keyword combinations (n-grams) that you wish to extract.').optional(),
    text: z.string().describe('The text that you want to analyze. It should not contain HTML tags.').optional(),
})

export type KeywordExtractionRequest = z.infer<typeof KeywordExtractionRequest>


export const LanguageDetectionRequest = z.object({
    api_key: z.string().describe('Your API Key'),
    text: z.string().describe('The text that you want to analyze. It should not contain HTML tags.').optional(),
})

export type LanguageDetectionRequest = z.infer<typeof LanguageDetectionRequest>


export const ReadabilityAssessmentRequest = z.object({
    api_key: z.string().describe('Your API Key'),
    text: z.string().describe('The text that you want to analyze. It should not contain HTML tags.').optional(),
})

export type ReadabilityAssessmentRequest = z.infer<typeof ReadabilityAssessmentRequest>


export const SentimentAnalysisRequest = z.object({
    api_key: z.string().describe('Your API Key'),
    text: z.string().describe('The text that you want to analyze. It should not contain HTML tags.').optional(),
})

export type SentimentAnalysisRequest = z.infer<typeof SentimentAnalysisRequest>


export const SpamDetectionRequest = z.object({
    api_key: z.string().describe('Your API Key'),
    text: z.string().describe('The text that you want to analyze. It should not contain HTML tags.').optional(),
})

export type SpamDetectionRequest = z.infer<typeof SpamDetectionRequest>


export const SubjectivityAnalysisRequest = z.object({
    api_key: z.string().describe('Your API Key'),
    text: z.string().describe('The text that you want to analyze. It should not contain HTML tags.').optional(),
})

export type SubjectivityAnalysisRequest = z.infer<typeof SubjectivityAnalysisRequest>


export const TextExtractionRequest = z.object({
    api_key: z.string().describe('Your API Key'),
    text: z.string().describe('The HTML source of the webpage.').optional(),
})

export type TextExtractionRequest = z.infer<typeof TextExtractionRequest>


export const TopicClassificationRequest = z.object({
    api_key: z.string().describe('Your API Key'),
    text: z.string().describe('The text that you want to analyze. It should not contain HTML tags.').optional(),
})

export type TopicClassificationRequest = z.infer<typeof TopicClassificationRequest>


export const TwitterSentimentAnalysisRequest = z.object({
    api_key: z.string().describe('Your API Key'),
    text: z.string().describe('The text of the tweet that we evaluate.').optional(),
})

export type TwitterSentimentAnalysisRequest = z.infer<typeof TwitterSentimentAnalysisRequest>


",
  },
}
`;
