// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`output generation - ajv 1`] = `
{
  "cleanFn": [Function],
  "outputFiles": {
    "examples/restclients/ajv/apimatic/apimatic.client.ts": "/**
* Generated by @skyleague/therefore@v1.0.0-local
* Do not manually touch this
*/
/* eslint-disable */

import type { IncomingHttpHeaders } from 'node:http'

import type { DefinedError } from 'ajv'
import { got } from 'got'
import type { CancelableRequest, Got, Options, OptionsInit, Response } from 'got'

import { ConvertApiRequest, ConvertApiResponse } from './apimatic.type.js'

/**
 * APIMATIC API Transformer
 * 
 * Transform API Descriptions from/to various formats
 */
export class Banking {
    public client: Got

    public auth: {
        apiKey?: string | (() => Promise<string>),basic?: [username: string, password: string] | (() => Promise<[username: string, password: string]>)
    }

    public availableAuth: Set<string>
    public defaultAuth: string[][] | string[] | undefined

    public constructor(
    {
        prefixUrl = 'https://apimatic.io/api/transform',
        options,
        auth = {},
        defaultAuth,
        client = got
    }: {
        prefixUrl?: string | 'https://apimatic.io/api/transform',
        options?: Options | OptionsInit,
        auth: {
            apiKey?: string | (() => Promise<string>),basic?: [username: string, password: string] | (() => Promise<[username: string, password: string]>)
        }
        defaultAuth?: string[][] | string[]
        client?: Got
    }) {
        this.client = client.extend(...[{ prefixUrl, throwHttpErrors: false }, options].filter((o): o is Options => o !== undefined))
        this.auth = auth
        this.availableAuth = new Set(Object.keys(auth))
        this.defaultAuth = defaultAuth
    }


    /**
     * POST /transform
     * 
     * Transform API Descriptions from/to various formats
     * 
     * Transform API Descriptions from/to various formats e.g., Swagger, API Blueprint, RAML, WADL, Google Discovery, I/O Docs.
     * 
     * ### INPUTS
     * * API Blueprint
     * * Swagger 1.0 - 1.2
     * * Swagger 2.0 JSON
     * * Swagger 2.0 YAML
     * * WADL - W3C 2009
     * * Google Discovery
     * * RAML 0.8
     * * I/O Docs - Mashery
     * * HAR 1.2
     * * Postman Collection 1.0 - 2.0
     * * APIMATIC Format
     * * Mashape
     * 
     * ### OUTPUTS
     * * API Blueprint
     * * Swagger 1.2
     * * Swagger 2.0 JSON
     * * Swagger 2.0 YAML
     * * WADL - W3C 2009
     * * RAML 0.8 - 1.0
     * * APIMATIC Format
     */
    public convertApi({body, query}: {body: ConvertApiRequest, query: { format: string }}): Promise<
    | SuccessResponse<'200', ConvertApiResponse>
    | FailureResponse<'429', unknown, 'response:statuscode'>
    | FailureResponse<undefined, unknown, 'request:body', undefined>
    | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
    | FailureResponse<Exclude<StatusCode<1 | 3 | 4 | 5>, "429">, unknown, 'response:statuscode', IncomingHttpHeaders>
    >
    {
        const _body = this.validateRequestBody(ConvertApiRequest, body)
        if ('left' in _body) {
        return Promise.resolve(_body)
        }


        return this.awaitResponse(this.buildClient().post('transform', {
            form: _body.right,searchParams: query,headers: { Accept: "application/json" },responseType: 'json',
        }), {
            200: ConvertApiResponse,429: { parse: (x: unknown) => ({ right: x }) },
        }) as ReturnType<this["convertApi"]>
    }

    public validateRequestBody<Body>(
    parser: { parse: (o: unknown) => { left: DefinedError[] } | { right: Body } }, body: unknown )
    {
        const _body = parser.parse(body)
        if ('left' in _body)
        {
            return {success: false as const, statusCode: undefined, status: undefined, headers: undefined, left: body, validationErrors: _body.left, where: 'request:body' } satisfies FailureResponse<undefined, unknown, 'request:body', undefined>
        }
        return _body
    }

    public async awaitResponse<I, S extends Record<PropertyKey, { parse: (o: I) => { left: DefinedError[] } | { right: unknown } }>>(response: 
    CancelableRequest<NoInfer<Response<I>>>
    , schemas: S) {
        const result = await response
        const status = result.statusCode < 200 ? 'informational' : result.statusCode < 300 ? 'success' : result.statusCode < 400 ? 'redirection' : result.statusCode < 500 ? 'client-error' : 'server-error'
        const validator = schemas[result.statusCode] ?? schemas.default
        const body = validator?.parse?.(result.body)
        if (result.statusCode < 200 || result.statusCode >= 300)
        {
            return {success: false as const, statusCode: result.statusCode.toString(), status, headers: result.headers, left: body !== undefined && 'right' in body ? body.right : result.body, validationErrors: body !== undefined && 'left' in body ? body.left : undefined, where: 'response:statuscode' } 
        }
        if (body === undefined || 'left' in body)
        {
            return {success: body === undefined, statusCode: result.statusCode.toString(), status, headers: result.headers, left: result.body, validationErrors: body?.left, where: 'response:body' }
        }
        return {success: true as const, statusCode: result.statusCode.toString(), status, headers: result.headers, right: result.body }
    }

    protected buildApiKeyClient(client: Got)
    {
        return client.extend({
        hooks: {
        beforeRequest: [
        async (options) => 
        {
            const apiKey = this.auth.apiKey
            const key = typeof apiKey === 'function' ? await apiKey() : apiKey
            options.headers.apikey = key
        }
        ],},})
    }


    protected buildBasicClient(client: Got)
    {
        return client.extend({
        hooks: {
        beforeRequest: [
        async (options) => 
        {
            const basic = this.auth.basic
            if (basic !== undefined)
            {
                const [username, password] = typeof basic === 'function' ? await basic() : basic
                options.username = username
                options.password = password
            }
        }
        ],},})
    }

    protected buildClient(auths: string[][] | string[] | undefined = this.defaultAuth, client?: Got): Got
    {
        const auth = (auths ?? [...this.availableAuth]).map(auth => Array.isArray(auth) ? auth : [auth]).filter((auth) => auth.every((a) => this.availableAuth.has(a)))
        let chosenClient = client ?? this.client
        for (const chosen of auth[0] ?? [])
        {
            if (chosen === 'apiKey')
            {
                chosenClient = this.buildApiKeyClient(chosenClient)
            }
            else
            if (chosen === 'basic')
            {
                chosenClient = this.buildBasicClient(chosenClient)
            }
        }
        return chosenClient
    }
}

export type Status<Major> = Major extends string ? Major extends \`1\${number}\`? 'informational': Major extends \`2\${number}\` ? 'success' : Major extends \`3\${number}\` ? 'redirection' : Major extends \`4\${number}\` ? 'client-error' : 'server-error' : undefined
export interface SuccessResponse<StatusCode extends string, T> { success: true; statusCode: StatusCode; status: Status<StatusCode>; headers: IncomingHttpHeaders; right: T }
export interface FailureResponse<StatusCode = string, T = unknown, Where = never, Headers = IncomingHttpHeaders> {
success: false
statusCode: StatusCode
status: Status<StatusCode>
headers: Headers
validationErrors: DefinedError[] | undefined
left: T
where: Where
}
export type StatusCode<Major extends number = 1 | 2 | 3 | 4 | 5> = \`\${Major}\${number}\`



",
    "examples/restclients/ajv/apimatic/apimatic.type.ts": "/**
* Generated by @skyleague/therefore@v1.0.0-local
* Do not manually touch this
*/
/* eslint-disable */

import type { DefinedError, ValidateFunction } from 'ajv'

import { validate as ConvertApiRequestValidator } from './schemas/convert-api-request.schema.js'
import { validate as ConvertApiResponseValidator } from './schemas/convert-api-response.schema.js'

export interface ConvertApiRequest {
    url?: (string | undefined)
}

export const ConvertApiRequest = {
    validate: ConvertApiRequestValidator as ValidateFunction<ConvertApiRequest>,
    get schema() { return ConvertApiRequest.validate.schema},
    get errors() { return ConvertApiRequest.validate.errors ?? undefined },
    is: (o: unknown): o is ConvertApiRequest => ConvertApiRequest.validate(o) === true,
    parse: (o: unknown): { right: ConvertApiRequest } | { left: DefinedError[] } => 
    {
        if(ConvertApiRequest.is(o)) {
            return { right: o }
        }
        return { left: (ConvertApiRequest.errors ?? []) as DefinedError[] }
    },
} as const


export interface ConvertApiResponse {
}

export const ConvertApiResponse = {
    validate: ConvertApiResponseValidator as ValidateFunction<ConvertApiResponse>,
    get schema() { return ConvertApiResponse.validate.schema},
    get errors() { return ConvertApiResponse.validate.errors ?? undefined },
    is: (o: unknown): o is ConvertApiResponse => ConvertApiResponse.validate(o) === true,
    parse: (o: unknown): { right: ConvertApiResponse } | { left: DefinedError[] } => 
    {
        if(ConvertApiResponse.is(o)) {
            return { right: o }
        }
        return { left: (ConvertApiResponse.errors ?? []) as DefinedError[] }
    },
} as const


",
    "examples/restclients/ajv/apimatic/schemas/convert-api-request.schema.js": "/* eslint-disable */
// @ts-nocheck
/**
 * Generated by Ajv https://ajv.js.org/guide/managing-schemas.html#standalone-validation-code
 */
"use strict";
/** @type {unknown} */
export const validate = validate10;export default validate10;const schema11 = {"$schema":"http://json-schema.org/draft-07/schema#","title":"ConvertApiRequest","type":"object","properties":{"url":{"type":"string"}},"additionalProperties":true};function validate10(data, {instancePath="", parentData, parentDataProperty, rootData=data}={}){let vErrors = null;let errors = 0;if(errors === 0){if(data && typeof data == "object" && !Array.isArray(data)){if(data.url !== undefined){if(typeof data.url !== "string"){validate10.errors = [{instancePath:instancePath+"/url",schemaPath:"#/properties/url/type",keyword:"type",params:{type: "string"},message:"must be string"}];return false;}}}else {validate10.errors = [{instancePath,schemaPath:"#/type",keyword:"type",params:{type: "object"},message:"must be object"}];return false;}}validate10.errors = vErrors;return errors === 0;};validate.schema=schema11;",
    "examples/restclients/ajv/apimatic/schemas/convert-api-response.schema.js": "/* eslint-disable */
// @ts-nocheck
/**
 * Generated by Ajv https://ajv.js.org/guide/managing-schemas.html#standalone-validation-code
 */
"use strict";
/** @type {unknown} */
export const validate = validate10;export default validate10;const schema11 = {"$schema":"http://json-schema.org/draft-07/schema#","title":"ConvertApiResponse","type":"object","additionalProperties":true};function validate10(data, {instancePath="", parentData, parentDataProperty, rootData=data}={}){let vErrors = null;let errors = 0;if(errors === 0){if(data && typeof data == "object" && !Array.isArray(data)){}else {validate10.errors = [{instancePath,schemaPath:"#/type",keyword:"type",params:{type: "object"},message:"must be object"}];return false;}}validate10.errors = vErrors;return errors === 0;};validate.schema=schema11;",
  },
}
`;

exports[`output generation - zod 1`] = `
{
  "cleanFn": [Function],
  "outputFiles": {
    "examples/restclients/zod/apimatic/apimatic.client.ts": "/**
* Generated by @skyleague/therefore@v1.0.0-local
* Do not manually touch this
*/
/* eslint-disable */

import type { IncomingHttpHeaders } from 'node:http'

import { got } from 'got'
import type { CancelableRequest, Got, Options, OptionsInit, Response } from 'got'
import type { SafeParseReturnType, ZodError } from 'zod'

import { ConvertApiRequest, ConvertApiResponse } from './apimatic.zod.js'

/**
 * APIMATIC API Transformer
 * 
 * Transform API Descriptions from/to various formats
 */
export class Banking {
    public client: Got

    public auth: {
        apiKey?: string | (() => Promise<string>),basic?: [username: string, password: string] | (() => Promise<[username: string, password: string]>)
    }

    public availableAuth: Set<string>
    public defaultAuth: string[][] | string[] | undefined

    public constructor(
    {
        prefixUrl = 'https://apimatic.io/api/transform',
        options,
        auth = {},
        defaultAuth,
        client = got
    }: {
        prefixUrl?: string | 'https://apimatic.io/api/transform',
        options?: Options | OptionsInit,
        auth: {
            apiKey?: string | (() => Promise<string>),basic?: [username: string, password: string] | (() => Promise<[username: string, password: string]>)
        }
        defaultAuth?: string[][] | string[]
        client?: Got
    }) {
        this.client = client.extend(...[{ prefixUrl, throwHttpErrors: false }, options].filter((o): o is Options => o !== undefined))
        this.auth = auth
        this.availableAuth = new Set(Object.keys(auth))
        this.defaultAuth = defaultAuth
    }


    /**
     * POST /transform
     * 
     * Transform API Descriptions from/to various formats
     * 
     * Transform API Descriptions from/to various formats e.g., Swagger, API Blueprint, RAML, WADL, Google Discovery, I/O Docs.
     * 
     * ### INPUTS
     * * API Blueprint
     * * Swagger 1.0 - 1.2
     * * Swagger 2.0 JSON
     * * Swagger 2.0 YAML
     * * WADL - W3C 2009
     * * Google Discovery
     * * RAML 0.8
     * * I/O Docs - Mashery
     * * HAR 1.2
     * * Postman Collection 1.0 - 2.0
     * * APIMATIC Format
     * * Mashape
     * 
     * ### OUTPUTS
     * * API Blueprint
     * * Swagger 1.2
     * * Swagger 2.0 JSON
     * * Swagger 2.0 YAML
     * * WADL - W3C 2009
     * * RAML 0.8 - 1.0
     * * APIMATIC Format
     */
    public convertApi({body, query}: {body: ConvertApiRequest, query: { format: string }}): Promise<
    | SuccessResponse<'200', ConvertApiResponse>
    | FailureResponse<'429', unknown, 'response:statuscode'>
    | FailureResponse<undefined, unknown, 'request:body', undefined>
    | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
    | FailureResponse<Exclude<StatusCode<1 | 3 | 4 | 5>, "429">, unknown, 'response:statuscode', IncomingHttpHeaders>
    >
    {
        const _body = this.validateRequestBody(ConvertApiRequest, body)
        if ('left' in _body) {
        return Promise.resolve(_body)
        }


        return this.awaitResponse(this.buildClient().post('transform', {
            form: _body.right,searchParams: query,headers: { Accept: "application/json" },responseType: 'json',
        }), {
            200: ConvertApiResponse,429: { safeParse: (x: unknown) => ({ success: true, data: x }) },
        }) as ReturnType<this["convertApi"]>
    }

    public validateRequestBody<Body>(
    parser: { safeParse: (o: unknown) => SafeParseReturnType<unknown, Body> }, body: unknown )
    : {right: Body } | FailureResponse<undefined, unknown, 'request:body', undefined> {
        const _body = parser.safeParse(body)
        if (!_body.success)
        {
            return {success: false as const, statusCode: undefined, status: undefined, headers: undefined, left: body, error: _body.error, where: 'request:body' } satisfies FailureResponse<undefined, unknown, 'request:body', undefined>
        }
        return {right: _body.data}
    }

    public async awaitResponse<I, S extends Record<PropertyKey, { safeParse: (o: unknown) => SafeParseReturnType<unknown, I> }>>(response: 
    CancelableRequest<NoInfer<Response<I>>>
    , schemas: S) {
        const result = await response
        const status = result.statusCode < 200 ? 'informational' : result.statusCode < 300 ? 'success' : result.statusCode < 400 ? 'redirection' : result.statusCode < 500 ? 'client-error' : 'server-error'
        const validator = schemas[result.statusCode] ?? schemas.default
        const body = validator?.safeParse?.(result.body)
        if (result.statusCode < 200 || result.statusCode >= 300)
        {
            return {success: false as const, statusCode: result.statusCode.toString(), status, headers: result.headers, left: body?.success ? body.data : result.body, error: body !== undefined && !body.success ? body.error : undefined, where: 'response:statuscode' } 
        }
        if (body === undefined || !body.success)
        {
            return {success: body === undefined, statusCode: result.statusCode.toString(), status, headers: result.headers, left: result.body, error: body?.error, where: 'response:body' }
        }
        return {success: true as const, statusCode: result.statusCode.toString(), status, headers: result.headers, right: body.data }
    }

    protected buildApiKeyClient(client: Got)
    {
        return client.extend({
        hooks: {
        beforeRequest: [
        async (options) => 
        {
            const apiKey = this.auth.apiKey
            const key = typeof apiKey === 'function' ? await apiKey() : apiKey
            options.headers.apikey = key
        }
        ],},})
    }


    protected buildBasicClient(client: Got)
    {
        return client.extend({
        hooks: {
        beforeRequest: [
        async (options) => 
        {
            const basic = this.auth.basic
            if (basic !== undefined)
            {
                const [username, password] = typeof basic === 'function' ? await basic() : basic
                options.username = username
                options.password = password
            }
        }
        ],},})
    }

    protected buildClient(auths: string[][] | string[] | undefined = this.defaultAuth, client?: Got): Got
    {
        const auth = (auths ?? [...this.availableAuth]).map(auth => Array.isArray(auth) ? auth : [auth]).filter((auth) => auth.every((a) => this.availableAuth.has(a)))
        let chosenClient = client ?? this.client
        for (const chosen of auth[0] ?? [])
        {
            if (chosen === 'apiKey')
            {
                chosenClient = this.buildApiKeyClient(chosenClient)
            }
            else
            if (chosen === 'basic')
            {
                chosenClient = this.buildBasicClient(chosenClient)
            }
        }
        return chosenClient
    }
}

export type Status<Major> = Major extends string ? Major extends \`1\${number}\`? 'informational': Major extends \`2\${number}\` ? 'success' : Major extends \`3\${number}\` ? 'redirection' : Major extends \`4\${number}\` ? 'client-error' : 'server-error' : undefined
export interface SuccessResponse<StatusCode extends string, T> { success: true; statusCode: StatusCode; status: Status<StatusCode>; headers: IncomingHttpHeaders; right: T }
export interface FailureResponse<StatusCode = string, T = unknown, Where = never, Headers = IncomingHttpHeaders> {
success: false
statusCode: StatusCode
status: Status<StatusCode>
headers: Headers
error: ZodError<T> | undefined
left: T
where: Where
}
export type StatusCode<Major extends number = 1 | 2 | 3 | 4 | 5> = \`\${Major}\${number}\`



",
    "examples/restclients/zod/apimatic/apimatic.zod.ts": "/**
* Generated by @skyleague/therefore@v1.0.0-local
* Do not manually touch this
*/
/* eslint-disable */

import { z } from 'zod'

export const ConvertApiRequest = z.object({
    url: z.string().optional(),
})

export const ConvertApiResponse = z.object({
})

export type ConvertApiRequest = z.infer<typeof ConvertApiRequest>

export type ConvertApiResponse = z.infer<typeof ConvertApiResponse>

",
  },
}
`;
