// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`output generation 1`] = `
{
  "cleanFn": [Function],
  "outputFiles": {
    "examples/restclients/apimatic/apimatic.client.ts": "/**
* Generated by @skyleague/therefore@v1.0.0-local
* Do not manually touch this
*/
/* eslint-disable */

import type { IncomingHttpHeaders } from 'node:http'

import type { DefinedError } from 'ajv'
import { got } from 'got'
import type { CancelableRequest, Got, Options, OptionsInit, Response } from 'got'

import { ConvertApiResponse } from './apimatic.type.js'

/**
 * APIMATIC API Transformer
 * 
 * Transform API Descriptions from/to various formats
 */
export class Banking {
    public client: Got

    public auth: {
        apiKey?: string | (() => Promise<string>),basic?: [username: string, password: string] | (() => Promise<[username: string, password: string]>)
    }

    public availableAuth: Set<string>
    public defaultAuth: string[][] | string[] | undefined

    public constructor(
    {
        prefixUrl = 'https://apimatic.io/api/transform',
        options,
        auth = {},
        defaultAuth,
    }: {
        prefixUrl?: string | 'https://apimatic.io/api/transform',
        options?: Options | OptionsInit,
        auth: {
            apiKey?: string | (() => Promise<string>),basic?: [username: string, password: string] | (() => Promise<[username: string, password: string]>)
        }
        defaultAuth?: string[][] | string[]
    }) {
        this.client = got.extend(...[{ prefixUrl, throwHttpErrors: false }, options].filter((o): o is Options => o !== undefined))
        this.auth = auth
        this.availableAuth = new Set(Object.keys(auth))
        this.defaultAuth = defaultAuth
    }


    /**
     * Transform API Descriptions from/to various formats
     * 
     * Transform API Descriptions from/to various formats e.g., Swagger, API Blueprint, RAML, WADL, Google Discovery, I/O Docs.
     * 
     * ### INPUTS
     * * API Blueprint
     * * Swagger 1.0 - 1.2
     * * Swagger 2.0 JSON
     * * Swagger 2.0 YAML
     * * WADL - W3C 2009
     * * Google Discovery
     * * RAML 0.8
     * * I/O Docs - Mashery
     * * HAR 1.2
     * * Postman Collection 1.0 - 2.0
     * * APIMATIC Format
     * * Mashape
     * 
     * ### OUTPUTS
     * * API Blueprint
     * * Swagger 1.2
     * * Swagger 2.0 JSON
     * * Swagger 2.0 YAML
     * * WADL - W3C 2009
     * * RAML 0.8 - 1.0
     * * APIMATIC Format
     */
    public convertApi({query}: {query: { format: string }}): Promise<
    | SuccessResponse<'200', ConvertApiResponse>
    | FailureResponse<'429', unknown, 'response:statuscode'>
    | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
    | FailureResponse<Exclude<StatusCode<1 | 3 | 4 | 5>, "429">, string, 'response:statuscode', IncomingHttpHeaders>
    >
    {
        return this.awaitResponse(this.buildClient().post('transform', {
            searchParams: query,headers: { Accept: "application/json" },responseType: 'json',
        }), {
            200: ConvertApiResponse,429: { parse: (x: unknown) => ({ right: x }) },
        }) as ReturnType<this["convertApi"]>
    }

    public async awaitResponse<I, S extends Record<PropertyKey, { parse: (o: I) => { left: DefinedError[] } | { right: unknown } } | undefined>>(response: CancelableRequest<Response<I>>, schemas: S)
    {
        const result = await response
        const status = result.statusCode < 200 ? 'informational' : result.statusCode < 300 ? 'success' : result.statusCode < 400 ? 'redirection' : result.statusCode < 500 ? 'client-error' : 'server-error'
        const validator = schemas[result.statusCode] ?? schemas.default
        const body = validator?.parse?.(result.body)
         if (result.statusCode < 200 || result.statusCode >= 300) 
        {
            return {statusCode: result.statusCode.toString(), status, headers: result.headers, left: body !== undefined && 'right' in body ? body.right : result.body, validationErrors: body !== undefined && 'left' in body ? body.left : undefined, where: 'response:statuscode' } 
        }
        if (body === undefined || 'left' in body)
        {
            return {statusCode: result.statusCode.toString(), status, headers: result.headers, left: result.body, validationErrors: body?.left, where: 'response:body' }
        }
        return {statusCode: result.statusCode.toString(), status, headers: result.headers, right: result.body }
    }

    protected buildApiKeyClient(client: Got)
    {
        return client.extend({
        hooks: {
        beforeRequest: [
        async (options) => 
        {
            const apiKey = this.auth.apiKey
            const key = typeof apiKey === 'function' ? await apiKey() : apiKey
            options.headers.apikey = key
        }
        ],},})
    }


    protected buildBasicClient(client: Got)
    {
        return client.extend({
        hooks: {
        beforeRequest: [
        async (options) => 
        {
            const basic = this.auth.basic
            if (basic !== undefined)
            {
                const [username, password] = typeof basic === 'function' ? await basic() : basic
                options.username = username
                options.password = password
            }
        }
        ],},})
    }

    protected buildClient(auths: string[][] | string[] | undefined = this.defaultAuth, client?: Got): Got
    {
        const auth = (auths ?? [...this.availableAuth]).map(auth => Array.isArray(auth) ? auth : [auth]).filter((auth) => auth.every((a) => this.availableAuth.has(a)))
        let chosenClient = client ?? this.client
        for (const chosen of auth[0] ?? [])
        {
            if (chosen === 'apiKey')
            {
                chosenClient = this.buildApiKeyClient(chosenClient)
            }
            else
            if (chosen === 'basic')
            {
                chosenClient = this.buildBasicClient(chosenClient)
            }
        }
        return chosenClient
    }
}

export type Status<Major> = Major extends string ? Major extends \`1\${number}\`? 'informational': Major extends \`2\${number}\` ? 'success' : Major extends \`3\${number}\` ? 'redirection' : Major extends \`4\${number}\` ? 'client-error' : 'server-error' : undefined
export interface SuccessResponse<StatusCode extends string, T> { statusCode: StatusCode; status: Status<StatusCode>; headers: IncomingHttpHeaders; right: T }
export interface FailureResponse<StatusCode = string, T = unknown, Where = never, Headers = IncomingHttpHeaders> {
                    statusCode: StatusCode
                    status: Status<StatusCode>
                    headers: Headers
                    validationErrors: DefinedError[] | undefined
                    left: T
                    where: Where
                }
export type StatusCode<Major extends number = 1 | 2 | 3 | 4 | 5> = \`\${Major}\${number}\`



",
    "examples/restclients/apimatic/apimatic.type.ts": "/**
* Generated by @skyleague/therefore@v1.0.0-local
* Do not manually touch this
*/
/* eslint-disable */

import type { DefinedError, ValidateFunction } from 'ajv'

import { validate as ConvertApiResponseValidator } from './schemas/convert-api-response.schema.js'

export interface ConvertApiResponse {
}

export const ConvertApiResponse = {
    validate: ConvertApiResponseValidator as ValidateFunction<ConvertApiResponse>,
    get schema() { return ConvertApiResponse.validate.schema},
    get errors() { return ConvertApiResponse.validate.errors ?? undefined },
    is: (o: unknown): o is ConvertApiResponse => ConvertApiResponse.validate(o) === true,
    parse: (o: unknown): { right: ConvertApiResponse } | { left: DefinedError[] } => 
    {
        if(ConvertApiResponse.is(o)) {
            return { right: o }
        }
        return { left: (ConvertApiResponse.errors ?? []) as DefinedError[] }
    },
} as const


",
    "examples/restclients/apimatic/schemas/convert-api-response.schema.js": "/* eslint-disable */
// @ts-nocheck
/**
 * Generated by Ajv https://ajv.js.org/guide/managing-schemas.html#standalone-validation-code
 */
"use strict";
/** @type {unknown} */
export const validate = validate10;export default validate10;const schema11 = {"$schema":"http://json-schema.org/draft-07/schema#","title":"ConvertApiResponse","type":"object","additionalProperties":true};function validate10(data, {instancePath="", parentData, parentDataProperty, rootData=data}={}){let vErrors = null;let errors = 0;if(errors === 0){if(data && typeof data == "object" && !Array.isArray(data)){}else {validate10.errors = [{instancePath,schemaPath:"#/type",keyword:"type",params:{type: "object"},message:"must be object"}];return false;}}validate10.errors = vErrors;return errors === 0;};validate.schema=schema11;",
  },
}
`;
