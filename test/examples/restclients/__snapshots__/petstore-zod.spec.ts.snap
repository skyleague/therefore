// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`output generation 1`] = `
{
  "cleanFn": [Function],
  "outputFiles": {
    "examples/restclients/zod/petstore/ky/petstore.client.ts": "/**
* Generated by @skyleague/therefore@v1.0.0-local
* Do not manually touch this
*/
/* eslint-disable */

import type { DefinedError } from 'ajv'
import ky from 'ky'
import type { KyInstance, Options, ResponsePromise } from 'ky'
import type { SafeParseReturnType, ZodError } from 'zod'

import { ApiResponse, CreateUsersWithListInputRequest, FindPetsByStatusResponse, FindPetsByTagsResponse, GetInventoryResponse, LoginUserResponse, Order, Pet, User } from './petstore.zod.js'

/**
 * Swagger Petstore - OpenAPI 3.0
 * 
 * This is a sample Pet Store Server based on the OpenAPI 3.0 specification.  You can find out more about
 * Swagger at [http://swagger.io](http://swagger.io). In the third iteration of the pet store, we've switched to the design first approach!
 * You can now help us improve the API whether it's by making changes to the definition itself or to the code.
 * That way, with time, we can improve the API in general, and expose some of the new features in OAS3.
 * 
 * Some useful links:
 * - [The Pet Store repository](https://github.com/swagger-api/swagger-petstore)
 * - [The source API definition for the Pet Store](https://github.com/swagger-api/swagger-petstore/blob/master/src/main/resources/openapi.yaml)
 */
export class PetStoreKy {
    public client: KyInstance

    public auth: {
        petstoreAuth?: string | (() => Promise<string>),apiKey?: string | (() => Promise<string>)
    }

    public availableAuth: Set<string>
    public defaultAuth: string[][] | string[] | undefined

    public constructor(
    {
        prefixUrl,
        options,
        auth = {},
        defaultAuth,
        client = ky
    }: {
        prefixUrl: string | \`\${string}/api/v3\`,
        options?: Options,
        auth: {
            petstoreAuth?: string | (() => Promise<string>),apiKey?: string | (() => Promise<string>)
        }
        defaultAuth?: string[][] | string[]
        client?: KyInstance
    }) {
        this.client = client.extend({ prefixUrl, throwHttpErrors: false, ...options })
        this.auth = auth
        this.availableAuth = new Set(Object.keys(auth))
        this.defaultAuth = defaultAuth
    }


    /**
     * POST /pet
     * 
     * Add a new pet to the store
     */
    public addPet({body, auth = [['petstoreAuth']]}: {body: Pet, auth?: string[][] | string[]}): Promise<
    | SuccessResponse<'200', Pet>
    | FailureResponse<'405', unknown, 'response:statuscode'>
    | FailureResponse<undefined, unknown, 'request:body', undefined>
    | FailureResponse<StatusCode<2>, string, 'response:body', Headers>
    | FailureResponse<Exclude<StatusCode<1 | 3 | 4 | 5>, "405">, unknown, 'response:statuscode', Headers>
    >
    {
        const _body = this.validateRequestBody(Pet, body)
        if ('left' in _body) {
        return Promise.resolve(_body)
        }


        return this.awaitResponse(this.buildClient(auth).post('pet', {
            json: _body.right,
        }), {
            200: Pet,405: { safeParse: (x: unknown) => ({ success: true, data: x }) },
        }
        , "json"
        ) as ReturnType<this["addPet"]>
    }

    /**
     * POST /user
     * 
     * Create user
     * 
     * This can only be done by the logged in user.
     */
    public createUser({body}: {body: User}): Promise<
    | SuccessResponse<StatusCode<2>, User>
    | FailureResponse<undefined, unknown, 'request:body', undefined>
    | FailureResponse<StatusCode<2>, string, 'response:body', Headers>
    | FailureResponse<StatusCode<1 | 3 | 4 | 5>, string, 'response:statuscode', Headers>
    >
    {
        const _body = this.validateRequestBody(User, body)
        if ('left' in _body) {
        return Promise.resolve(_body)
        }


        return this.awaitResponse(this.client.post('user', {
            json: _body.right,
        }), {
            default: User,
        }
        , "json"
        ) as ReturnType<this["createUser"]>
    }

    /**
     * POST /user/createWithList
     * 
     * Creates list of users with given input array
     */
    public createUsersWithListInput({body}: {body: CreateUsersWithListInputRequest}): Promise<
    | SuccessResponse<'200', User>
    | FailureResponse<undefined, unknown, 'request:body', undefined>
    | FailureResponse<StatusCode<2>, string, 'response:body', Headers>
    | FailureResponse<StatusCode<1 | 3 | 4 | 5>, string, 'response:statuscode', Headers>
    >
    {
        const _body = this.validateRequestBody(CreateUsersWithListInputRequest, body)
        if ('left' in _body) {
        return Promise.resolve(_body)
        }


        return this.awaitResponse(this.client.post('user/createWithList', {
            json: _body.right,
        }), {
            200: User,
        }
        , "json"
        ) as ReturnType<this["createUsersWithListInput"]>
    }

    /**
     * DELETE /store/order/{orderId}
     * 
     * Delete purchase order by ID
     * 
     * For valid response try integer IDs with value < 1000. Anything above 1000 or nonintegers will generate API errors
     */
    public deleteOrder({path}: {path: { orderId: string }}): Promise<
    | FailureResponse<'400', unknown, 'response:statuscode'>
    | FailureResponse<'404', unknown, 'response:statuscode'>
    | FailureResponse<StatusCode<2>, string, 'response:body', Headers>
    | FailureResponse<Exclude<StatusCode<1 | 3 | 4 | 5>, "400" | "404">, unknown, 'response:statuscode', Headers>
    >
    {
        return this.awaitResponse(this.client.delete(\`store/order/\${path.orderId}\`, {
        }), {
            400: { safeParse: (x: unknown) => ({ success: true, data: x }) },404: { safeParse: (x: unknown) => ({ success: true, data: x }) },
        }
        , "text"
        ) as ReturnType<this["deleteOrder"]>
    }

    /**
     * DELETE /pet/{petId}
     * 
     * Deletes a pet
     */
    public deletePet({path, headers, auth = [['petstoreAuth']]}: {path: { petId: string }, headers?: { api_key?: string }, auth?: string[][] | string[]}): Promise<
    | FailureResponse<'400', unknown, 'response:statuscode'>
    | FailureResponse<StatusCode<2>, string, 'response:body', Headers>
    | FailureResponse<Exclude<StatusCode<1 | 3 | 4 | 5>, "400">, unknown, 'response:statuscode', Headers>
    >
    {
        return this.awaitResponse(this.buildClient(auth).delete(\`pet/\${path.petId}\`, {
            headers: headers ?? {},
        }), {
            400: { safeParse: (x: unknown) => ({ success: true, data: x }) },
        }
        , "text"
        ) as ReturnType<this["deletePet"]>
    }

    /**
     * DELETE /user/{username}
     * 
     * Delete user
     * 
     * This can only be done by the logged in user.
     */
    public deleteUser({path}: {path: { username: string }}): Promise<
    | FailureResponse<'400', unknown, 'response:statuscode'>
    | FailureResponse<'404', unknown, 'response:statuscode'>
    | FailureResponse<StatusCode<2>, string, 'response:body', Headers>
    | FailureResponse<Exclude<StatusCode<1 | 3 | 4 | 5>, "400" | "404">, unknown, 'response:statuscode', Headers>
    >
    {
        return this.awaitResponse(this.client.delete(\`user/\${path.username}\`, {
        }), {
            400: { safeParse: (x: unknown) => ({ success: true, data: x }) },404: { safeParse: (x: unknown) => ({ success: true, data: x }) },
        }
        , "text"
        ) as ReturnType<this["deleteUser"]>
    }

    /**
     * GET /pet/findByStatus
     * 
     * Finds Pets by status
     * 
     * Multiple status values can be provided with comma separated strings
     */
    public findPetsByStatus({query, auth = [['petstoreAuth']]}: {query?: { status?: string }, auth?: string[][] | string[]} = {}): Promise<
    | SuccessResponse<'200', FindPetsByStatusResponse>
    | FailureResponse<'400', unknown, 'response:statuscode'>
    | FailureResponse<StatusCode<2>, string, 'response:body', Headers>
    | FailureResponse<Exclude<StatusCode<1 | 3 | 4 | 5>, "400">, unknown, 'response:statuscode', Headers>
    >
    {
        return this.awaitResponse(this.buildClient(auth).get('pet/findByStatus', {
            searchParams: query ?? {},
        }), {
            200: FindPetsByStatusResponse,400: { safeParse: (x: unknown) => ({ success: true, data: x }) },
        }
        , "json"
        ) as ReturnType<this["findPetsByStatus"]>
    }

    /**
     * GET /pet/findByTags
     * 
     * Finds Pets by tags
     * 
     * Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.
     */
    public findPetsByTags({query, auth = [['petstoreAuth']]}: {query?: { tags?: string }, auth?: string[][] | string[]} = {}): Promise<
    | SuccessResponse<'200', FindPetsByTagsResponse>
    | FailureResponse<'400', unknown, 'response:statuscode'>
    | FailureResponse<StatusCode<2>, string, 'response:body', Headers>
    | FailureResponse<Exclude<StatusCode<1 | 3 | 4 | 5>, "400">, unknown, 'response:statuscode', Headers>
    >
    {
        return this.awaitResponse(this.buildClient(auth).get('pet/findByTags', {
            searchParams: query ?? {},
        }), {
            200: FindPetsByTagsResponse,400: { safeParse: (x: unknown) => ({ success: true, data: x }) },
        }
        , "json"
        ) as ReturnType<this["findPetsByTags"]>
    }

    /**
     * GET /store/inventory
     * 
     * Returns pet inventories by status
     * 
     * Returns a map of status codes to quantities
     */
    public getInventory({auth = [['apiKey']]}: {auth?: string[][] | string[]} = {}): Promise<
    | SuccessResponse<'200', GetInventoryResponse>
    | FailureResponse<StatusCode<2>, string, 'response:body', Headers>
    | FailureResponse<StatusCode<1 | 3 | 4 | 5>, string, 'response:statuscode', Headers>
    >
    {
        return this.awaitResponse(this.buildClient(auth).get('store/inventory', {
        }), {
            200: GetInventoryResponse,
        }
        , "json"
        ) as ReturnType<this["getInventory"]>
    }

    /**
     * GET /store/order/{orderId}
     * 
     * Find purchase order by ID
     * 
     * For valid response try integer IDs with value <= 5 or > 10. Other values will generate exceptions.
     */
    public getOrderById({path}: {path: { orderId: string }}): Promise<
    | SuccessResponse<'200', Order>
    | FailureResponse<'400', unknown, 'response:statuscode'>
    | FailureResponse<'404', unknown, 'response:statuscode'>
    | FailureResponse<StatusCode<2>, string, 'response:body', Headers>
    | FailureResponse<Exclude<StatusCode<1 | 3 | 4 | 5>, "400" | "404">, unknown, 'response:statuscode', Headers>
    >
    {
        return this.awaitResponse(this.client.get(\`store/order/\${path.orderId}\`, {
        }), {
            200: Order,400: { safeParse: (x: unknown) => ({ success: true, data: x }) },404: { safeParse: (x: unknown) => ({ success: true, data: x }) },
        }
        , "json"
        ) as ReturnType<this["getOrderById"]>
    }

    /**
     * GET /pet/{petId}
     * 
     * Find pet by ID
     * 
     * Returns a single pet
     */
    public getPetById({path, auth = [['apiKey'], ['petstoreAuth']]}: {path: { petId: string }, auth?: string[][] | string[]}): Promise<
    | SuccessResponse<'200', Pet>
    | FailureResponse<'400', unknown, 'response:statuscode'>
    | FailureResponse<'404', unknown, 'response:statuscode'>
    | FailureResponse<StatusCode<2>, string, 'response:body', Headers>
    | FailureResponse<Exclude<StatusCode<1 | 3 | 4 | 5>, "400" | "404">, unknown, 'response:statuscode', Headers>
    >
    {
        return this.awaitResponse(this.buildClient(auth).get(\`pet/\${path.petId}\`, {
        }), {
            200: Pet,400: { safeParse: (x: unknown) => ({ success: true, data: x }) },404: { safeParse: (x: unknown) => ({ success: true, data: x }) },
        }
        , "json"
        ) as ReturnType<this["getPetById"]>
    }

    /**
     * GET /user/{username}
     * 
     * Get user by user name
     */
    public getUserByName({path}: {path: { username: string }}): Promise<
    | SuccessResponse<'200', User>
    | FailureResponse<'400', unknown, 'response:statuscode'>
    | FailureResponse<'404', unknown, 'response:statuscode'>
    | FailureResponse<StatusCode<2>, string, 'response:body', Headers>
    | FailureResponse<Exclude<StatusCode<1 | 3 | 4 | 5>, "400" | "404">, unknown, 'response:statuscode', Headers>
    >
    {
        return this.awaitResponse(this.client.get(\`user/\${path.username}\`, {
        }), {
            200: User,400: { safeParse: (x: unknown) => ({ success: true, data: x }) },404: { safeParse: (x: unknown) => ({ success: true, data: x }) },
        }
        , "json"
        ) as ReturnType<this["getUserByName"]>
    }

    /**
     * GET /user/login
     * 
     * Logs user into the system
     */
    public loginUser({query}: {query?: { username?: string, password?: string }} = {}): Promise<
    | SuccessResponse<'200', LoginUserResponse>
    | FailureResponse<'400', unknown, 'response:statuscode'>
    | FailureResponse<StatusCode<2>, string, 'response:body', Headers>
    | FailureResponse<Exclude<StatusCode<1 | 3 | 4 | 5>, "400">, unknown, 'response:statuscode', Headers>
    >
    {
        return this.awaitResponse(this.client.get('user/login', {
            searchParams: query ?? {},
        }), {
            200: LoginUserResponse,400: { safeParse: (x: unknown) => ({ success: true, data: x }) },
        }
        , "json"
        ) as ReturnType<this["loginUser"]>
    }

    /**
     * GET /user/logout
     * 
     * Logs out current logged in user session
     */
    public logoutUser(): Promise<
    | FailureResponse<StatusCode<2>, string, 'response:body', Headers>
    | FailureResponse<StatusCode<1 | 3 | 4 | 5>, string, 'response:statuscode', Headers>
    >
    {
        return this.awaitResponse(this.client.get('user/logout', {
        }), {
        }
        , "text"
        ) as ReturnType<this["logoutUser"]>
    }

    /**
     * POST /store/order
     * 
     * Place an order for a pet
     * 
     * Place a new order in the store
     */
    public placeOrder({body}: {body: Order}): Promise<
    | SuccessResponse<'200', Order>
    | FailureResponse<'405', unknown, 'response:statuscode'>
    | FailureResponse<undefined, unknown, 'request:body', undefined>
    | FailureResponse<StatusCode<2>, string, 'response:body', Headers>
    | FailureResponse<Exclude<StatusCode<1 | 3 | 4 | 5>, "405">, unknown, 'response:statuscode', Headers>
    >
    {
        const _body = this.validateRequestBody(Order, body)
        if ('left' in _body) {
        return Promise.resolve(_body)
        }


        return this.awaitResponse(this.client.post('store/order', {
            json: _body.right,
        }), {
            200: Order,405: { safeParse: (x: unknown) => ({ success: true, data: x }) },
        }
        , "json"
        ) as ReturnType<this["placeOrder"]>
    }

    /**
     * PUT /pet
     * 
     * Update an existing pet
     * 
     * Update an existing pet by Id
     */
    public updatePet({body, auth = [['petstoreAuth']]}: {body: Pet, auth?: string[][] | string[]}): Promise<
    | SuccessResponse<'200', Pet>
    | FailureResponse<'400', unknown, 'response:statuscode'>
    | FailureResponse<'404', unknown, 'response:statuscode'>
    | FailureResponse<'405', unknown, 'response:statuscode'>
    | FailureResponse<undefined, unknown, 'request:body', undefined>
    | FailureResponse<StatusCode<2>, string, 'response:body', Headers>
    | FailureResponse<Exclude<StatusCode<1 | 3 | 4 | 5>, "400" | "404" | "405">, unknown, 'response:statuscode', Headers>
    >
    {
        const _body = this.validateRequestBody(Pet, body)
        if ('left' in _body) {
        return Promise.resolve(_body)
        }


        return this.awaitResponse(this.buildClient(auth).put('pet', {
            json: _body.right,
        }), {
            200: Pet,400: { safeParse: (x: unknown) => ({ success: true, data: x }) },404: { safeParse: (x: unknown) => ({ success: true, data: x }) },405: { safeParse: (x: unknown) => ({ success: true, data: x }) },
        }
        , "json"
        ) as ReturnType<this["updatePet"]>
    }

    /**
     * POST /pet/{petId}
     * 
     * Updates a pet in the store with form data
     */
    public updatePetWithForm({path, query, auth = [['petstoreAuth']]}: {path: { petId: string }, query?: { name?: string, status?: string }, auth?: string[][] | string[]}): Promise<
    | FailureResponse<'405', unknown, 'response:statuscode'>
    | FailureResponse<StatusCode<2>, string, 'response:body', Headers>
    | FailureResponse<Exclude<StatusCode<1 | 3 | 4 | 5>, "405">, unknown, 'response:statuscode', Headers>
    >
    {
        return this.awaitResponse(this.buildClient(auth).post(\`pet/\${path.petId}\`, {
            searchParams: query ?? {},
        }), {
            405: { safeParse: (x: unknown) => ({ success: true, data: x }) },
        }
        , "text"
        ) as ReturnType<this["updatePetWithForm"]>
    }

    /**
     * PUT /user/{username}
     * 
     * Update user
     * 
     * This can only be done by the logged in user.
     */
    public updateUser({body, path}: {body: User, path: { username: string }}): Promise<
    | FailureResponse<undefined, unknown, 'request:body', undefined>
    | FailureResponse<StatusCode<2>, string, 'response:body', Headers>
    | FailureResponse<StatusCode<1 | 3 | 4 | 5>, string, 'response:statuscode', Headers>
    >
    {
        const _body = this.validateRequestBody(User, body)
        if ('left' in _body) {
        return Promise.resolve(_body)
        }


        return this.awaitResponse(this.client.put(\`user/\${path.username}\`, {
            json: _body.right,
        }), {
        }
        , "text"
        ) as ReturnType<this["updateUser"]>
    }

    /**
     * POST /pet/{petId}/uploadImage
     * 
     * uploads an image
     */
    public uploadFile({body, path, query, auth = [['petstoreAuth']]}: {body: string | Buffer, path: { petId: string }, query?: { additionalMetadata?: string }, auth?: string[][] | string[]}): Promise<
    | SuccessResponse<'200', ApiResponse>
    | FailureResponse<StatusCode<2>, string, 'response:body', Headers>
    | FailureResponse<StatusCode<1 | 3 | 4 | 5>, string, 'response:statuscode', Headers>
    >
    {
        return this.awaitResponse(this.buildClient(auth).post(\`pet/\${path.petId}/uploadImage\`, {
            body: body,searchParams: query ?? {},
        }), {
            200: ApiResponse,
        }
        , "json"
        ) as ReturnType<this["uploadFile"]>
    }

    public validateRequestBody<Body>(
    parser: { safeParse: (o: unknown) => SafeParseReturnType<unknown, Body> }, body: unknown )
    : {right: Body } | FailureResponse<undefined, unknown, 'request:body', undefined> {
        const _body = parser.safeParse(body)
        if (!_body.success)
        {
            return {success: false as const, statusCode: undefined, status: undefined, headers: undefined, left: body, error: _body.error, where: 'request:body' } satisfies FailureResponse<undefined, unknown, 'request:body', undefined>
        }
        return {right: _body.data}
    }

    public async awaitResponse<I, S extends Record<PropertyKey, { safeParse: (o: unknown) => SafeParseReturnType<unknown, I> }>>(response: 
    ResponsePromise<I>, schemas: S, responseType?: "json" | "text") {
        const _body = (await (responseType !== undefined ? response[responseType]() : response.text())) as I
        const result = await response
        const status = result.status < 200 ? 'informational' : result.status < 300 ? 'success' : result.status < 400 ? 'redirection' : result.status < 500 ? 'client-error' : 'server-error'
        const validator = schemas[result.status] ?? schemas.default
        const body = validator?.safeParse?.(_body)
        if (result.status < 200 || result.status >= 300)
        {
            return {success: false as const, statusCode: result.status.toString(), status, headers: result.headers, left: body?.success ? body.data : _body, error: body !== undefined && !body.success ? body.error : undefined, where: 'response:statuscode' } 
        }
        if (body === undefined || !body.success)
        {
            return {success: body === undefined, statusCode: result.status.toString(), status, headers: result.headers, left: _body, error: body?.error, where: 'response:body' }
        }
        return {success: true as const, statusCode: result.status.toString(), status, headers: result.headers, right: body.data }
    }

    protected buildPetstoreAuthClient(client: KyInstance)
    {
        return client
    }


    protected buildApiKeyClient(client: KyInstance)
    {
        return client.extend({
        hooks: {
        beforeRequest: [
        async (options) => 
        {
            const apiKey = this.auth.apiKey
            const key = typeof apiKey === 'function' ? await apiKey() : apiKey
            options.headers.set('api_key', \`\${key}\`)
        }
        ],},})
    }

    protected buildClient(auths: string[][] | string[] | undefined = this.defaultAuth, client?: KyInstance): KyInstance
    {
        const auth = (auths ?? [...this.availableAuth]).map(auth => Array.isArray(auth) ? auth : [auth]).filter((auth) => auth.every((a) => this.availableAuth.has(a)))
        let chosenClient = client ?? this.client
        for (const chosen of auth[0] ?? [])
        {
            if (chosen === 'petstoreAuth')
            {
                chosenClient = this.buildPetstoreAuthClient(chosenClient)
            }
            else
            if (chosen === 'apiKey')
            {
                chosenClient = this.buildApiKeyClient(chosenClient)
            }
        }
        return chosenClient
    }
}

export type Status<Major> = Major extends string ? Major extends \`1\${number}\`? 'informational': Major extends \`2\${number}\` ? 'success' : Major extends \`3\${number}\` ? 'redirection' : Major extends \`4\${number}\` ? 'client-error' : 'server-error' : undefined
export interface SuccessResponse<StatusCode extends string, T> { success: true; statusCode: StatusCode; status: Status<StatusCode>; headers: Headers; right: T }
export interface FailureResponse<StatusCode = string, T = unknown, Where = never, HeaderResponse = Headers> {
success: false
statusCode: StatusCode
status: Status<StatusCode>
headers: HeaderResponse
error: ZodError<T> | undefined
left: T
where: Where
}
export type StatusCode<Major extends number = 1 | 2 | 3 | 4 | 5> = \`\${Major}\${number}\`



",
    "examples/restclients/zod/petstore/ky/petstore.zod.ts": "/**
* Generated by @skyleague/therefore@v1.0.0-local
* Do not manually touch this
*/
/* eslint-disable */

import { z } from 'zod'

export const Tag = z.object({
    id: z.number().int().optional(),
    name: z.string().optional(),
})

export const Category = z.object({
    id: z.number().int().optional(),
    name: z.string().optional(),
})

export const User = z.object({
    email: z.string().optional(),
    firstName: z.string().optional(),
    id: z.number().int().optional(),
    lastName: z.string().optional(),
    password: z.string().optional(),
    phone: z.string().optional(),
    username: z.string().optional(),
    userStatus: z.number().int().describe('User Status').optional(),
})

export const Pet = z.object({
    category: Category.optional(),
    id: z.number().int().optional(),
    name: z.string(),
    photoUrls: z.array(z.string()),
    status: z.enum(['available', 'pending', 'sold']).describe('pet status in the store').optional(),
    tags: z.array(Tag).optional(),
})

export const ApiResponse = z.object({
    code: z.number().int().optional(),
    message: z.string().optional(),
    type: z.string().optional(),
})

export const CreateUsersWithListInputRequest = z.array(User)

export const FindPetsByStatusResponse = z.array(Pet)

export const FindPetsByTagsResponse = z.array(Pet)

export const GetInventoryResponse = z.record(z.number().int().optional())

export const LoginUserResponse = z.string()

export const Order = z.object({
    complete: z.boolean().optional(),
    id: z.number().int().optional(),
    petId: z.number().int().optional(),
    quantity: z.number().int().optional(),
    shipDate: z.string().datetime({ offset: true }).optional(),
    status: z.enum(['placed', 'approved', 'delivered']).describe('Order Status').optional(),
})

export type ApiResponse = z.infer<typeof ApiResponse>

export type CreateUsersWithListInputRequest = z.infer<typeof CreateUsersWithListInputRequest>

export type FindPetsByStatusResponse = z.infer<typeof FindPetsByStatusResponse>

export type FindPetsByTagsResponse = z.infer<typeof FindPetsByTagsResponse>

export type GetInventoryResponse = z.infer<typeof GetInventoryResponse>

export type LoginUserResponse = z.infer<typeof LoginUserResponse>

export type Order = z.infer<typeof Order>

export type Pet = z.infer<typeof Pet>

export type User = z.infer<typeof User>

",
    "examples/restclients/zod/petstore/oky/petstore.client.ts": "/**
* Generated by @skyleague/therefore@v1.0.0-local
* Do not manually touch this
*/
/* eslint-disable */

import ky from 'ky'
import type { KyInstance, Options, ResponsePromise } from 'ky'

import { ApiResponse, CreateUsersWithListInputRequest, FindPetsByStatusResponse, FindPetsByTagsResponse, GetInventoryResponse, LoginUserResponse, Order, Pet, User } from './petstore.zod.js'

/**
 * Swagger Petstore - OpenAPI 3.0
 * 
 * This is a sample Pet Store Server based on the OpenAPI 3.0 specification.  You can find out more about
 * Swagger at [http://swagger.io](http://swagger.io). In the third iteration of the pet store, we've switched to the design first approach!
 * You can now help us improve the API whether it's by making changes to the definition itself or to the code.
 * That way, with time, we can improve the API in general, and expose some of the new features in OAS3.
 * 
 * Some useful links:
 * - [The Pet Store repository](https://github.com/swagger-api/swagger-petstore)
 * - [The source API definition for the Pet Store](https://github.com/swagger-api/swagger-petstore/blob/master/src/main/resources/openapi.yaml)
 */
export class PetStoreOptionsKy {
    public client: KyInstance

    public auth: {
        petstoreAuth?: string | (() => Promise<string>),apiKey?: string | (() => Promise<string>)
    }

    public availableAuth: Set<string>
    public defaultAuth: string[][] | string[] | undefined

    public constructor(
    {
        prefixUrl,
        options,
        auth = {},
        defaultAuth,
        client = ky
    }: {
        prefixUrl: string | \`\${string}/api/v3\`,
        options?: Options,
        auth: {
            petstoreAuth?: string | (() => Promise<string>),apiKey?: string | (() => Promise<string>)
        }
        defaultAuth?: string[][] | string[]
        client?: KyInstance
    }) {
        this.client = client.extend({ prefixUrl, ...options })
        this.auth = auth
        this.availableAuth = new Set(Object.keys(auth))
        this.defaultAuth = defaultAuth
    }


    /**
     * POST /pet
     * 
     * Add a new pet to the store
     */
    public addPet({body, auth = [['petstoreAuth']]}: {body: Pet, auth?: string[][] | string[]})
    {
        this.validateRequestBody(Pet, body)

        return this.awaitResponse(this.buildClient(auth).post('pet', {
            json: body,
        }), {
            200: Pet,405: {parse: (x: unknown): string => x as string},
        }
        , "json"
        )
    }

    /**
     * POST /user
     * 
     * Create user
     * 
     * This can only be done by the logged in user.
     */
    public createUser({body}: {body: User})
    {
        this.validateRequestBody(User, body)

        return this.awaitResponse(this.client.post('user', {
            json: body,
        }), {
            default: User,
        }
        , "json"
        )
    }

    /**
     * POST /user/createWithList
     * 
     * Creates list of users with given input array
     */
    public createUsersWithListInput({body}: {body: CreateUsersWithListInputRequest})
    {
        this.validateRequestBody(CreateUsersWithListInputRequest, body)

        return this.awaitResponse(this.client.post('user/createWithList', {
            json: body,
        }), {
            200: User,
        }
        , "json"
        )
    }

    /**
     * DELETE /store/order/{orderId}
     * 
     * Delete purchase order by ID
     * 
     * For valid response try integer IDs with value < 1000. Anything above 1000 or nonintegers will generate API errors
     */
    public deleteOrder({path}: {path: { orderId: string }})
    {
        return this.awaitResponse(this.client.delete(\`store/order/\${path.orderId}\`, {
        }), {
            400: {parse: (x: unknown): string => x as string},404: {parse: (x: unknown): string => x as string},
        }
        , "text"
        )
    }

    /**
     * DELETE /pet/{petId}
     * 
     * Deletes a pet
     */
    public deletePet({path, headers, auth = [['petstoreAuth']]}: {path: { petId: string }, headers?: { api_key?: string }, auth?: string[][] | string[]})
    {
        return this.awaitResponse(this.buildClient(auth).delete(\`pet/\${path.petId}\`, {
            headers: headers ?? {},
        }), {
            400: {parse: (x: unknown): string => x as string},
        }
        , "text"
        )
    }

    /**
     * DELETE /user/{username}
     * 
     * Delete user
     * 
     * This can only be done by the logged in user.
     */
    public deleteUser({path}: {path: { username: string }})
    {
        return this.awaitResponse(this.client.delete(\`user/\${path.username}\`, {
        }), {
            400: {parse: (x: unknown): string => x as string},404: {parse: (x: unknown): string => x as string},
        }
        , "text"
        )
    }

    /**
     * GET /pet/findByStatus
     * 
     * Finds Pets by status
     * 
     * Multiple status values can be provided with comma separated strings
     */
    public findPetsByStatus({query, auth = [['petstoreAuth']]}: {query?: { status?: string }, auth?: string[][] | string[]} = {})
    {
        return this.awaitResponse(this.buildClient(auth).get('pet/findByStatus', {
            searchParams: query ?? {},
        }), {
            200: FindPetsByStatusResponse,400: {parse: (x: unknown): string => x as string},
        }
        , "json"
        )
    }

    /**
     * GET /pet/findByTags
     * 
     * Finds Pets by tags
     * 
     * Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.
     */
    public findPetsByTags({query, auth = [['petstoreAuth']]}: {query?: { tags?: string }, auth?: string[][] | string[]} = {})
    {
        return this.awaitResponse(this.buildClient(auth).get('pet/findByTags', {
            searchParams: query ?? {},
        }), {
            200: FindPetsByTagsResponse,400: {parse: (x: unknown): string => x as string},
        }
        , "json"
        )
    }

    /**
     * GET /store/inventory
     * 
     * Returns pet inventories by status
     * 
     * Returns a map of status codes to quantities
     */
    public getInventory({auth = [['apiKey']]}: {auth?: string[][] | string[]} = {})
    {
        return this.awaitResponse(this.buildClient(auth).get('store/inventory', {
        }), {
            200: GetInventoryResponse,
        }
        , "json"
        )
    }

    /**
     * GET /store/order/{orderId}
     * 
     * Find purchase order by ID
     * 
     * For valid response try integer IDs with value <= 5 or > 10. Other values will generate exceptions.
     */
    public getOrderById({path}: {path: { orderId: string }})
    {
        return this.awaitResponse(this.client.get(\`store/order/\${path.orderId}\`, {
        }), {
            200: Order,400: {parse: (x: unknown): string => x as string},404: {parse: (x: unknown): string => x as string},
        }
        , "json"
        )
    }

    /**
     * GET /pet/{petId}
     * 
     * Find pet by ID
     * 
     * Returns a single pet
     */
    public getPetById({path, auth = [['apiKey'], ['petstoreAuth']]}: {path: { petId: string }, auth?: string[][] | string[]})
    {
        return this.awaitResponse(this.buildClient(auth).get(\`pet/\${path.petId}\`, {
        }), {
            200: Pet,400: {parse: (x: unknown): string => x as string},404: {parse: (x: unknown): string => x as string},
        }
        , "json"
        )
    }

    /**
     * GET /user/{username}
     * 
     * Get user by user name
     */
    public getUserByName({path}: {path: { username: string }})
    {
        return this.awaitResponse(this.client.get(\`user/\${path.username}\`, {
        }), {
            200: User,400: {parse: (x: unknown): string => x as string},404: {parse: (x: unknown): string => x as string},
        }
        , "json"
        )
    }

    /**
     * GET /user/login
     * 
     * Logs user into the system
     */
    public loginUser({query}: {query?: { username?: string, password?: string }} = {})
    {
        return this.awaitResponse(this.client.get('user/login', {
            searchParams: query ?? {},
        }), {
            200: LoginUserResponse,400: {parse: (x: unknown): string => x as string},
        }
        , "json"
        )
    }

    /**
     * GET /user/logout
     * 
     * Logs out current logged in user session
     */
    public logoutUser()
    {
        return this.awaitResponse(this.client.get('user/logout', {
        }), {
        }
        , "text"
        )
    }

    /**
     * POST /store/order
     * 
     * Place an order for a pet
     * 
     * Place a new order in the store
     */
    public placeOrder({body}: {body: Order})
    {
        this.validateRequestBody(Order, body)

        return this.awaitResponse(this.client.post('store/order', {
            json: body,
        }), {
            200: Order,405: {parse: (x: unknown): string => x as string},
        }
        , "json"
        )
    }

    /**
     * PUT /pet
     * 
     * Update an existing pet
     * 
     * Update an existing pet by Id
     */
    public updatePet({body, auth = [['petstoreAuth']]}: {body: Pet, auth?: string[][] | string[]})
    {
        this.validateRequestBody(Pet, body)

        return this.awaitResponse(this.buildClient(auth).put('pet', {
            json: body,
        }), {
            200: Pet,400: {parse: (x: unknown): string => x as string},404: {parse: (x: unknown): string => x as string},405: {parse: (x: unknown): string => x as string},
        }
        , "json"
        )
    }

    /**
     * POST /pet/{petId}
     * 
     * Updates a pet in the store with form data
     */
    public updatePetWithForm({path, query, auth = [['petstoreAuth']]}: {path: { petId: string }, query?: { name?: string, status?: string }, auth?: string[][] | string[]})
    {
        return this.awaitResponse(this.buildClient(auth).post(\`pet/\${path.petId}\`, {
            searchParams: query ?? {},
        }), {
            405: {parse: (x: unknown): string => x as string},
        }
        , "text"
        )
    }

    /**
     * PUT /user/{username}
     * 
     * Update user
     * 
     * This can only be done by the logged in user.
     */
    public updateUser({body, path}: {body: User, path: { username: string }})
    {
        this.validateRequestBody(User, body)

        return this.awaitResponse(this.client.put(\`user/\${path.username}\`, {
            json: body,
        }), {
        }
        , "text"
        )
    }

    /**
     * POST /pet/{petId}/uploadImage
     * 
     * uploads an image
     */
    public uploadFile({body, path, query, auth = [['petstoreAuth']]}: {body: string | Buffer, path: { petId: string }, query?: { additionalMetadata?: string }, auth?: string[][] | string[]})
    {
        return this.awaitResponse(this.buildClient(auth).post(\`pet/\${path.petId}/uploadImage\`, {
            body: body,searchParams: query ?? {},
        }), {
            200: ApiResponse,
        }
        , "json"
        )
    }

    public validateRequestBody<Body>( parser: { parse: (o: unknown) => Body }, body: unknown )
    {
        return parser.parse(body)
    }

    public async awaitResponse<I, S extends Record<PropertyKey, { parse: (o: unknown) => I }>>(response: 
    ResponsePromise, schemas: S, responseType?: "json" | "text") {
        type FilterStartingWith<S extends PropertyKey, T extends string> = S extends number | string ? \`\${S}\` extends \`\${T}\${infer _X}\` ? S : never : never
        type InferSchemaType<T> = T extends { is: (o: unknown) => o is infer S } ? S : never
        const result = await response
        const _body = responseType !== undefined ? result[responseType](): result.text()
        const schema = schemas[result.status] ?? schemas.default
        const body = schema?.parse?.(_body) ?? _body
        return {statusCode: result.status, headers: result.headers, body: body as InferSchemaType<S[keyof Pick<S, FilterStartingWith<keyof S, '2' | 'default'>>]> }
    }

    protected buildPetstoreAuthClient(client: KyInstance)
    {
        return client
    }


    protected buildApiKeyClient(client: KyInstance)
    {
        return client.extend({
        hooks: {
        beforeRequest: [
        async (options) => 
        {
            const apiKey = this.auth.apiKey
            const key = typeof apiKey === 'function' ? await apiKey() : apiKey
            options.headers.set('api_key', \`\${key}\`)
        }
        ],},})
    }

    protected buildClient(auths: string[][] | string[] | undefined = this.defaultAuth, client?: KyInstance): KyInstance
    {
        const auth = (auths ?? [...this.availableAuth]).map(auth => Array.isArray(auth) ? auth : [auth]).filter((auth) => auth.every((a) => this.availableAuth.has(a)))
        let chosenClient = client ?? this.client
        for (const chosen of auth[0] ?? [])
        {
            if (chosen === 'petstoreAuth')
            {
                chosenClient = this.buildPetstoreAuthClient(chosenClient)
            }
            else
            if (chosen === 'apiKey')
            {
                chosenClient = this.buildApiKeyClient(chosenClient)
            }
        }
        return chosenClient
    }
}

",
    "examples/restclients/zod/petstore/oky/petstore.zod.ts": "/**
* Generated by @skyleague/therefore@v1.0.0-local
* Do not manually touch this
*/
/* eslint-disable */

import { z } from 'zod'

export const Tag = z.object({
    id: z.number().int().optional(),
    name: z.string().optional(),
})

export const Category = z.object({
    id: z.number().int().optional(),
    name: z.string().optional(),
})

export const User = z.object({
    email: z.string().optional(),
    firstName: z.string().optional(),
    id: z.number().int().optional(),
    lastName: z.string().optional(),
    password: z.string().optional(),
    phone: z.string().optional(),
    username: z.string().optional(),
    userStatus: z.number().int().describe('User Status').optional(),
})

export const Pet = z.object({
    category: Category.optional(),
    id: z.number().int().optional(),
    name: z.string(),
    photoUrls: z.array(z.string()),
    status: z.enum(['available', 'pending', 'sold']).describe('pet status in the store').optional(),
    tags: z.array(Tag).optional(),
})

export const ApiResponse = z.object({
    code: z.number().int().optional(),
    message: z.string().optional(),
    type: z.string().optional(),
})

export const CreateUsersWithListInputRequest = z.array(User)

export const FindPetsByStatusResponse = z.array(Pet)

export const FindPetsByTagsResponse = z.array(Pet)

export const GetInventoryResponse = z.record(z.number().int().optional())

export const LoginUserResponse = z.string()

export const Order = z.object({
    complete: z.boolean().optional(),
    id: z.number().int().optional(),
    petId: z.number().int().optional(),
    quantity: z.number().int().optional(),
    shipDate: z.string().datetime({ offset: true }).optional(),
    status: z.enum(['placed', 'approved', 'delivered']).describe('Order Status').optional(),
})

export type ApiResponse = z.infer<typeof ApiResponse>

export type CreateUsersWithListInputRequest = z.infer<typeof CreateUsersWithListInputRequest>

export type FindPetsByStatusResponse = z.infer<typeof FindPetsByStatusResponse>

export type FindPetsByTagsResponse = z.infer<typeof FindPetsByTagsResponse>

export type GetInventoryResponse = z.infer<typeof GetInventoryResponse>

export type LoginUserResponse = z.infer<typeof LoginUserResponse>

export type Order = z.infer<typeof Order>

export type Pet = z.infer<typeof Pet>

export type User = z.infer<typeof User>

",
    "examples/restclients/zod/petstore/options/petstore.client.ts": "/**
* Generated by @skyleague/therefore@v1.0.0-local
* Do not manually touch this
*/
/* eslint-disable */

import { got } from 'got'
import type { CancelableRequest, Got, Options, OptionsInit, Response } from 'got'

import { ApiResponse, CreateUsersWithListInputRequest, FindPetsByStatusResponse, FindPetsByTagsResponse, GetInventoryResponse, LoginUserResponse, Order, Pet, User } from './petstore.zod.js'

/**
 * Swagger Petstore - OpenAPI 3.0
 * 
 * This is a sample Pet Store Server based on the OpenAPI 3.0 specification.  You can find out more about
 * Swagger at [http://swagger.io](http://swagger.io). In the third iteration of the pet store, we've switched to the design first approach!
 * You can now help us improve the API whether it's by making changes to the definition itself or to the code.
 * That way, with time, we can improve the API in general, and expose some of the new features in OAS3.
 * 
 * Some useful links:
 * - [The Pet Store repository](https://github.com/swagger-api/swagger-petstore)
 * - [The source API definition for the Pet Store](https://github.com/swagger-api/swagger-petstore/blob/master/src/main/resources/openapi.yaml)
 */
export class PetStoreOptions {
    public client: Got

    public auth: {
        petstoreAuth?: string | (() => Promise<string>),apiKey?: string | (() => Promise<string>)
    }

    public availableAuth: Set<string>
    public defaultAuth: string[][] | string[] | undefined

    public constructor(
    {
        prefixUrl,
        options,
        auth = {},
        defaultAuth,
        client = got
    }: {
        prefixUrl: string | \`\${string}/api/v3\`,
        options?: Options | OptionsInit,
        auth: {
            petstoreAuth?: string | (() => Promise<string>),apiKey?: string | (() => Promise<string>)
        }
        defaultAuth?: string[][] | string[]
        client?: Got
    }) {
        this.client = client.extend(...[{ prefixUrl }, options].filter((o): o is Options => o !== undefined))
        this.auth = auth
        this.availableAuth = new Set(Object.keys(auth))
        this.defaultAuth = defaultAuth
    }


    /**
     * POST /pet
     * 
     * Add a new pet to the store
     */
    public addPet({body, auth = [['petstoreAuth']]}: {body: Pet, auth?: string[][] | string[]})
    {
        this.validateRequestBody(Pet, body)

        return this.awaitResponse(this.buildClient(auth).post('pet', {
            json: body,responseType: 'json',
        }), {
            200: Pet,405: {parse: (x: unknown): string => x as string},
        })
    }

    /**
     * POST /user
     * 
     * Create user
     * 
     * This can only be done by the logged in user.
     */
    public createUser({body}: {body: User})
    {
        this.validateRequestBody(User, body)

        return this.awaitResponse(this.client.post('user', {
            json: body,responseType: 'json',
        }), {
            default: User,
        })
    }

    /**
     * POST /user/createWithList
     * 
     * Creates list of users with given input array
     */
    public createUsersWithListInput({body}: {body: CreateUsersWithListInputRequest})
    {
        this.validateRequestBody(CreateUsersWithListInputRequest, body)

        return this.awaitResponse(this.client.post('user/createWithList', {
            json: body,responseType: 'json',
        }), {
            200: User,
        })
    }

    /**
     * DELETE /store/order/{orderId}
     * 
     * Delete purchase order by ID
     * 
     * For valid response try integer IDs with value < 1000. Anything above 1000 or nonintegers will generate API errors
     */
    public deleteOrder({path}: {path: { orderId: string }})
    {
        return this.awaitResponse(this.client.delete(\`store/order/\${path.orderId}\`, {
            responseType: 'text',
        }), {
            400: {parse: (x: unknown): string => x as string},404: {parse: (x: unknown): string => x as string},
        })
    }

    /**
     * DELETE /pet/{petId}
     * 
     * Deletes a pet
     */
    public deletePet({path, headers, auth = [['petstoreAuth']]}: {path: { petId: string }, headers?: { api_key?: string }, auth?: string[][] | string[]})
    {
        return this.awaitResponse(this.buildClient(auth).delete(\`pet/\${path.petId}\`, {
            headers: headers ?? {},responseType: 'text',
        }), {
            400: {parse: (x: unknown): string => x as string},
        })
    }

    /**
     * DELETE /user/{username}
     * 
     * Delete user
     * 
     * This can only be done by the logged in user.
     */
    public deleteUser({path}: {path: { username: string }})
    {
        return this.awaitResponse(this.client.delete(\`user/\${path.username}\`, {
            responseType: 'text',
        }), {
            400: {parse: (x: unknown): string => x as string},404: {parse: (x: unknown): string => x as string},
        })
    }

    /**
     * GET /pet/findByStatus
     * 
     * Finds Pets by status
     * 
     * Multiple status values can be provided with comma separated strings
     */
    public findPetsByStatus({query, auth = [['petstoreAuth']]}: {query?: { status?: string }, auth?: string[][] | string[]} = {})
    {
        return this.awaitResponse(this.buildClient(auth).get('pet/findByStatus', {
            searchParams: query ?? {},responseType: 'json',
        }), {
            200: FindPetsByStatusResponse,400: {parse: (x: unknown): string => x as string},
        })
    }

    /**
     * GET /pet/findByTags
     * 
     * Finds Pets by tags
     * 
     * Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.
     */
    public findPetsByTags({query, auth = [['petstoreAuth']]}: {query?: { tags?: string }, auth?: string[][] | string[]} = {})
    {
        return this.awaitResponse(this.buildClient(auth).get('pet/findByTags', {
            searchParams: query ?? {},responseType: 'json',
        }), {
            200: FindPetsByTagsResponse,400: {parse: (x: unknown): string => x as string},
        })
    }

    /**
     * GET /store/inventory
     * 
     * Returns pet inventories by status
     * 
     * Returns a map of status codes to quantities
     */
    public getInventory({auth = [['apiKey']]}: {auth?: string[][] | string[]} = {})
    {
        return this.awaitResponse(this.buildClient(auth).get('store/inventory', {
            responseType: 'json',
        }), {
            200: GetInventoryResponse,
        })
    }

    /**
     * GET /store/order/{orderId}
     * 
     * Find purchase order by ID
     * 
     * For valid response try integer IDs with value <= 5 or > 10. Other values will generate exceptions.
     */
    public getOrderById({path}: {path: { orderId: string }})
    {
        return this.awaitResponse(this.client.get(\`store/order/\${path.orderId}\`, {
            responseType: 'json',
        }), {
            200: Order,400: {parse: (x: unknown): string => x as string},404: {parse: (x: unknown): string => x as string},
        })
    }

    /**
     * GET /pet/{petId}
     * 
     * Find pet by ID
     * 
     * Returns a single pet
     */
    public getPetById({path, auth = [['apiKey'], ['petstoreAuth']]}: {path: { petId: string }, auth?: string[][] | string[]})
    {
        return this.awaitResponse(this.buildClient(auth).get(\`pet/\${path.petId}\`, {
            responseType: 'json',
        }), {
            200: Pet,400: {parse: (x: unknown): string => x as string},404: {parse: (x: unknown): string => x as string},
        })
    }

    /**
     * GET /user/{username}
     * 
     * Get user by user name
     */
    public getUserByName({path}: {path: { username: string }})
    {
        return this.awaitResponse(this.client.get(\`user/\${path.username}\`, {
            responseType: 'json',
        }), {
            200: User,400: {parse: (x: unknown): string => x as string},404: {parse: (x: unknown): string => x as string},
        })
    }

    /**
     * GET /user/login
     * 
     * Logs user into the system
     */
    public loginUser({query}: {query?: { username?: string, password?: string }} = {})
    {
        return this.awaitResponse(this.client.get('user/login', {
            searchParams: query ?? {},responseType: 'json',
        }), {
            200: LoginUserResponse,400: {parse: (x: unknown): string => x as string},
        })
    }

    /**
     * GET /user/logout
     * 
     * Logs out current logged in user session
     */
    public logoutUser()
    {
        return this.awaitResponse(this.client.get('user/logout', {
            responseType: 'text',
        }), {
        })
    }

    /**
     * POST /store/order
     * 
     * Place an order for a pet
     * 
     * Place a new order in the store
     */
    public placeOrder({body}: {body: Order})
    {
        this.validateRequestBody(Order, body)

        return this.awaitResponse(this.client.post('store/order', {
            json: body,responseType: 'json',
        }), {
            200: Order,405: {parse: (x: unknown): string => x as string},
        })
    }

    /**
     * PUT /pet
     * 
     * Update an existing pet
     * 
     * Update an existing pet by Id
     */
    public updatePet({body, auth = [['petstoreAuth']]}: {body: Pet, auth?: string[][] | string[]})
    {
        this.validateRequestBody(Pet, body)

        return this.awaitResponse(this.buildClient(auth).put('pet', {
            json: body,responseType: 'json',
        }), {
            200: Pet,400: {parse: (x: unknown): string => x as string},404: {parse: (x: unknown): string => x as string},405: {parse: (x: unknown): string => x as string},
        })
    }

    /**
     * POST /pet/{petId}
     * 
     * Updates a pet in the store with form data
     */
    public updatePetWithForm({path, query, auth = [['petstoreAuth']]}: {path: { petId: string }, query?: { name?: string, status?: string }, auth?: string[][] | string[]})
    {
        return this.awaitResponse(this.buildClient(auth).post(\`pet/\${path.petId}\`, {
            searchParams: query ?? {},responseType: 'text',
        }), {
            405: {parse: (x: unknown): string => x as string},
        })
    }

    /**
     * PUT /user/{username}
     * 
     * Update user
     * 
     * This can only be done by the logged in user.
     */
    public updateUser({body, path}: {body: User, path: { username: string }})
    {
        this.validateRequestBody(User, body)

        return this.awaitResponse(this.client.put(\`user/\${path.username}\`, {
            json: body,responseType: 'text',
        }), {
        })
    }

    /**
     * POST /pet/{petId}/uploadImage
     * 
     * uploads an image
     */
    public uploadFile({body, path, query, auth = [['petstoreAuth']]}: {body: string | Buffer, path: { petId: string }, query?: { additionalMetadata?: string }, auth?: string[][] | string[]})
    {
        return this.awaitResponse(this.buildClient(auth).post(\`pet/\${path.petId}/uploadImage\`, {
            body: body,searchParams: query ?? {},responseType: 'json',
        }), {
            200: ApiResponse,
        })
    }

    public validateRequestBody<Body>( parser: { parse: (o: unknown) => Body }, body: unknown )
    {
        return parser.parse(body)
    }

    public async awaitResponse<I, S extends Record<PropertyKey, { parse: (o: unknown) => I }>>(response: 
    CancelableRequest<Response>
    , schemas: S) {
        type FilterStartingWith<S extends PropertyKey, T extends string> = S extends number | string ? \`\${S}\` extends \`\${T}\${infer _X}\` ? S : never : never
        type InferSchemaType<T> = T extends { is: (o: unknown) => o is infer S } ? S : never
        const result = await response
        const schema = schemas[result.statusCode] ?? schemas.default
        const body = schema?.parse?.(result.body) ?? result.body
        return {statusCode: result.statusCode, headers: result.headers, body: body as InferSchemaType<S[keyof Pick<S, FilterStartingWith<keyof S, '2' | 'default'>>]> }
    }

    protected buildPetstoreAuthClient(client: Got)
    {
        return client
    }


    protected buildApiKeyClient(client: Got)
    {
        return client.extend({
        hooks: {
        beforeRequest: [
        async (options) => 
        {
            const apiKey = this.auth.apiKey
            const key = typeof apiKey === 'function' ? await apiKey() : apiKey
            options.headers.api_key = key
        }
        ],},})
    }

    protected buildClient(auths: string[][] | string[] | undefined = this.defaultAuth, client?: Got): Got
    {
        const auth = (auths ?? [...this.availableAuth]).map(auth => Array.isArray(auth) ? auth : [auth]).filter((auth) => auth.every((a) => this.availableAuth.has(a)))
        let chosenClient = client ?? this.client
        for (const chosen of auth[0] ?? [])
        {
            if (chosen === 'petstoreAuth')
            {
                chosenClient = this.buildPetstoreAuthClient(chosenClient)
            }
            else
            if (chosen === 'apiKey')
            {
                chosenClient = this.buildApiKeyClient(chosenClient)
            }
        }
        return chosenClient
    }
}

",
    "examples/restclients/zod/petstore/options/petstore.zod.ts": "/**
* Generated by @skyleague/therefore@v1.0.0-local
* Do not manually touch this
*/
/* eslint-disable */

import { z } from 'zod'

export const Tag = z.object({
    id: z.number().int().optional(),
    name: z.string().optional(),
})

export const Category = z.object({
    id: z.number().int().optional(),
    name: z.string().optional(),
})

export const User = z.object({
    email: z.string().optional(),
    firstName: z.string().optional(),
    id: z.number().int().optional(),
    lastName: z.string().optional(),
    password: z.string().optional(),
    phone: z.string().optional(),
    username: z.string().optional(),
    userStatus: z.number().int().describe('User Status').optional(),
})

export const Pet = z.object({
    category: Category.optional(),
    id: z.number().int().optional(),
    name: z.string(),
    photoUrls: z.array(z.string()),
    status: z.enum(['available', 'pending', 'sold']).describe('pet status in the store').optional(),
    tags: z.array(Tag).optional(),
})

export const ApiResponse = z.object({
    code: z.number().int().optional(),
    message: z.string().optional(),
    type: z.string().optional(),
})

export const CreateUsersWithListInputRequest = z.array(User)

export const FindPetsByStatusResponse = z.array(Pet)

export const FindPetsByTagsResponse = z.array(Pet)

export const GetInventoryResponse = z.record(z.number().int().optional())

export const LoginUserResponse = z.string()

export const Order = z.object({
    complete: z.boolean().optional(),
    id: z.number().int().optional(),
    petId: z.number().int().optional(),
    quantity: z.number().int().optional(),
    shipDate: z.string().datetime({ offset: true }).optional(),
    status: z.enum(['placed', 'approved', 'delivered']).describe('Order Status').optional(),
})

export type ApiResponse = z.infer<typeof ApiResponse>

export type CreateUsersWithListInputRequest = z.infer<typeof CreateUsersWithListInputRequest>

export type FindPetsByStatusResponse = z.infer<typeof FindPetsByStatusResponse>

export type FindPetsByTagsResponse = z.infer<typeof FindPetsByTagsResponse>

export type GetInventoryResponse = z.infer<typeof GetInventoryResponse>

export type LoginUserResponse = z.infer<typeof LoginUserResponse>

export type Order = z.infer<typeof Order>

export type Pet = z.infer<typeof Pet>

export type User = z.infer<typeof User>

",
    "examples/restclients/zod/petstore/petstore.client.ts": "/**
* Generated by @skyleague/therefore@v1.0.0-local
* Do not manually touch this
*/
/* eslint-disable */

import type { IncomingHttpHeaders } from 'node:http'

import type { DefinedError } from 'ajv'
import { got } from 'got'
import type { CancelableRequest, Got, Options, OptionsInit, Response } from 'got'
import type { SafeParseReturnType, ZodError } from 'zod'

import { ApiResponse, CreateUsersWithListInputRequest, FindPetsByStatusResponse, FindPetsByTagsResponse, GetInventoryResponse, LoginUserResponse, Order, Pet, User } from './petstore.zod.js'

/**
 * Swagger Petstore - OpenAPI 3.0
 * 
 * This is a sample Pet Store Server based on the OpenAPI 3.0 specification.  You can find out more about
 * Swagger at [http://swagger.io](http://swagger.io). In the third iteration of the pet store, we've switched to the design first approach!
 * You can now help us improve the API whether it's by making changes to the definition itself or to the code.
 * That way, with time, we can improve the API in general, and expose some of the new features in OAS3.
 * 
 * Some useful links:
 * - [The Pet Store repository](https://github.com/swagger-api/swagger-petstore)
 * - [The source API definition for the Pet Store](https://github.com/swagger-api/swagger-petstore/blob/master/src/main/resources/openapi.yaml)
 */
export class PetStore {
    public client: Got

    public auth: {
        petstoreAuth?: string | (() => Promise<string>),apiKey?: string | (() => Promise<string>)
    }

    public availableAuth: Set<string>
    public defaultAuth: string[][] | string[] | undefined

    public constructor(
    {
        prefixUrl,
        options,
        auth = {},
        defaultAuth,
        client = got
    }: {
        prefixUrl: string | \`\${string}/api/v3\`,
        options?: Options | OptionsInit,
        auth: {
            petstoreAuth?: string | (() => Promise<string>),apiKey?: string | (() => Promise<string>)
        }
        defaultAuth?: string[][] | string[]
        client?: Got
    }) {
        this.client = client.extend(...[{ prefixUrl, throwHttpErrors: false }, options].filter((o): o is Options => o !== undefined))
        this.auth = auth
        this.availableAuth = new Set(Object.keys(auth))
        this.defaultAuth = defaultAuth
    }


    /**
     * POST /pet
     * 
     * Add a new pet to the store
     */
    public addPet({body, auth = [['petstoreAuth']]}: {body: Pet, auth?: string[][] | string[]}): Promise<
    | SuccessResponse<'200', Pet>
    | FailureResponse<'405', unknown, 'response:statuscode'>
    | FailureResponse<undefined, unknown, 'request:body', undefined>
    | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
    | FailureResponse<Exclude<StatusCode<1 | 3 | 4 | 5>, "405">, unknown, 'response:statuscode', IncomingHttpHeaders>
    >
    {
        const _body = this.validateRequestBody(Pet, body)
        if ('left' in _body) {
        return Promise.resolve(_body)
        }


        return this.awaitResponse(this.buildClient(auth).post('pet', {
            json: _body.right,responseType: 'json',
        }), {
            200: Pet,405: { safeParse: (x: unknown) => ({ success: true, data: x }) },
        }) as ReturnType<this["addPet"]>
    }

    /**
     * POST /user
     * 
     * Create user
     * 
     * This can only be done by the logged in user.
     */
    public createUser({body}: {body: User}): Promise<
    | SuccessResponse<StatusCode<2>, User>
    | FailureResponse<undefined, unknown, 'request:body', undefined>
    | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
    | FailureResponse<StatusCode<1 | 3 | 4 | 5>, string, 'response:statuscode', IncomingHttpHeaders>
    >
    {
        const _body = this.validateRequestBody(User, body)
        if ('left' in _body) {
        return Promise.resolve(_body)
        }


        return this.awaitResponse(this.client.post('user', {
            json: _body.right,responseType: 'json',
        }), {
            default: User,
        }) as ReturnType<this["createUser"]>
    }

    /**
     * POST /user/createWithList
     * 
     * Creates list of users with given input array
     */
    public createUsersWithListInput({body}: {body: CreateUsersWithListInputRequest}): Promise<
    | SuccessResponse<'200', User>
    | FailureResponse<undefined, unknown, 'request:body', undefined>
    | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
    | FailureResponse<StatusCode<1 | 3 | 4 | 5>, string, 'response:statuscode', IncomingHttpHeaders>
    >
    {
        const _body = this.validateRequestBody(CreateUsersWithListInputRequest, body)
        if ('left' in _body) {
        return Promise.resolve(_body)
        }


        return this.awaitResponse(this.client.post('user/createWithList', {
            json: _body.right,responseType: 'json',
        }), {
            200: User,
        }) as ReturnType<this["createUsersWithListInput"]>
    }

    /**
     * DELETE /store/order/{orderId}
     * 
     * Delete purchase order by ID
     * 
     * For valid response try integer IDs with value < 1000. Anything above 1000 or nonintegers will generate API errors
     */
    public deleteOrder({path}: {path: { orderId: string }}): Promise<
    | FailureResponse<'400', unknown, 'response:statuscode'>
    | FailureResponse<'404', unknown, 'response:statuscode'>
    | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
    | FailureResponse<Exclude<StatusCode<1 | 3 | 4 | 5>, "400" | "404">, unknown, 'response:statuscode', IncomingHttpHeaders>
    >
    {
        return this.awaitResponse(this.client.delete(\`store/order/\${path.orderId}\`, {
            responseType: 'text',
        }), {
            400: { safeParse: (x: unknown) => ({ success: true, data: x }) },404: { safeParse: (x: unknown) => ({ success: true, data: x }) },
        }) as ReturnType<this["deleteOrder"]>
    }

    /**
     * DELETE /pet/{petId}
     * 
     * Deletes a pet
     */
    public deletePet({path, headers, auth = [['petstoreAuth']]}: {path: { petId: string }, headers?: { api_key?: string }, auth?: string[][] | string[]}): Promise<
    | FailureResponse<'400', unknown, 'response:statuscode'>
    | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
    | FailureResponse<Exclude<StatusCode<1 | 3 | 4 | 5>, "400">, unknown, 'response:statuscode', IncomingHttpHeaders>
    >
    {
        return this.awaitResponse(this.buildClient(auth).delete(\`pet/\${path.petId}\`, {
            headers: headers ?? {},responseType: 'text',
        }), {
            400: { safeParse: (x: unknown) => ({ success: true, data: x }) },
        }) as ReturnType<this["deletePet"]>
    }

    /**
     * DELETE /user/{username}
     * 
     * Delete user
     * 
     * This can only be done by the logged in user.
     */
    public deleteUser({path}: {path: { username: string }}): Promise<
    | FailureResponse<'400', unknown, 'response:statuscode'>
    | FailureResponse<'404', unknown, 'response:statuscode'>
    | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
    | FailureResponse<Exclude<StatusCode<1 | 3 | 4 | 5>, "400" | "404">, unknown, 'response:statuscode', IncomingHttpHeaders>
    >
    {
        return this.awaitResponse(this.client.delete(\`user/\${path.username}\`, {
            responseType: 'text',
        }), {
            400: { safeParse: (x: unknown) => ({ success: true, data: x }) },404: { safeParse: (x: unknown) => ({ success: true, data: x }) },
        }) as ReturnType<this["deleteUser"]>
    }

    /**
     * GET /pet/findByStatus
     * 
     * Finds Pets by status
     * 
     * Multiple status values can be provided with comma separated strings
     */
    public findPetsByStatus({query, auth = [['petstoreAuth']]}: {query?: { status?: string }, auth?: string[][] | string[]} = {}): Promise<
    | SuccessResponse<'200', FindPetsByStatusResponse>
    | FailureResponse<'400', unknown, 'response:statuscode'>
    | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
    | FailureResponse<Exclude<StatusCode<1 | 3 | 4 | 5>, "400">, unknown, 'response:statuscode', IncomingHttpHeaders>
    >
    {
        return this.awaitResponse(this.buildClient(auth).get('pet/findByStatus', {
            searchParams: query ?? {},responseType: 'json',
        }), {
            200: FindPetsByStatusResponse,400: { safeParse: (x: unknown) => ({ success: true, data: x }) },
        }) as ReturnType<this["findPetsByStatus"]>
    }

    /**
     * GET /pet/findByTags
     * 
     * Finds Pets by tags
     * 
     * Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.
     */
    public findPetsByTags({query, auth = [['petstoreAuth']]}: {query?: { tags?: string }, auth?: string[][] | string[]} = {}): Promise<
    | SuccessResponse<'200', FindPetsByTagsResponse>
    | FailureResponse<'400', unknown, 'response:statuscode'>
    | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
    | FailureResponse<Exclude<StatusCode<1 | 3 | 4 | 5>, "400">, unknown, 'response:statuscode', IncomingHttpHeaders>
    >
    {
        return this.awaitResponse(this.buildClient(auth).get('pet/findByTags', {
            searchParams: query ?? {},responseType: 'json',
        }), {
            200: FindPetsByTagsResponse,400: { safeParse: (x: unknown) => ({ success: true, data: x }) },
        }) as ReturnType<this["findPetsByTags"]>
    }

    /**
     * GET /store/inventory
     * 
     * Returns pet inventories by status
     * 
     * Returns a map of status codes to quantities
     */
    public getInventory({auth = [['apiKey']]}: {auth?: string[][] | string[]} = {}): Promise<
    | SuccessResponse<'200', GetInventoryResponse>
    | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
    | FailureResponse<StatusCode<1 | 3 | 4 | 5>, string, 'response:statuscode', IncomingHttpHeaders>
    >
    {
        return this.awaitResponse(this.buildClient(auth).get('store/inventory', {
            responseType: 'json',
        }), {
            200: GetInventoryResponse,
        }) as ReturnType<this["getInventory"]>
    }

    /**
     * GET /store/order/{orderId}
     * 
     * Find purchase order by ID
     * 
     * For valid response try integer IDs with value <= 5 or > 10. Other values will generate exceptions.
     */
    public getOrderById({path}: {path: { orderId: string }}): Promise<
    | SuccessResponse<'200', Order>
    | FailureResponse<'400', unknown, 'response:statuscode'>
    | FailureResponse<'404', unknown, 'response:statuscode'>
    | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
    | FailureResponse<Exclude<StatusCode<1 | 3 | 4 | 5>, "400" | "404">, unknown, 'response:statuscode', IncomingHttpHeaders>
    >
    {
        return this.awaitResponse(this.client.get(\`store/order/\${path.orderId}\`, {
            responseType: 'json',
        }), {
            200: Order,400: { safeParse: (x: unknown) => ({ success: true, data: x }) },404: { safeParse: (x: unknown) => ({ success: true, data: x }) },
        }) as ReturnType<this["getOrderById"]>
    }

    /**
     * GET /pet/{petId}
     * 
     * Find pet by ID
     * 
     * Returns a single pet
     */
    public getPetById({path, auth = [['apiKey'], ['petstoreAuth']]}: {path: { petId: string }, auth?: string[][] | string[]}): Promise<
    | SuccessResponse<'200', Pet>
    | FailureResponse<'400', unknown, 'response:statuscode'>
    | FailureResponse<'404', unknown, 'response:statuscode'>
    | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
    | FailureResponse<Exclude<StatusCode<1 | 3 | 4 | 5>, "400" | "404">, unknown, 'response:statuscode', IncomingHttpHeaders>
    >
    {
        return this.awaitResponse(this.buildClient(auth).get(\`pet/\${path.petId}\`, {
            responseType: 'json',
        }), {
            200: Pet,400: { safeParse: (x: unknown) => ({ success: true, data: x }) },404: { safeParse: (x: unknown) => ({ success: true, data: x }) },
        }) as ReturnType<this["getPetById"]>
    }

    /**
     * GET /user/{username}
     * 
     * Get user by user name
     */
    public getUserByName({path}: {path: { username: string }}): Promise<
    | SuccessResponse<'200', User>
    | FailureResponse<'400', unknown, 'response:statuscode'>
    | FailureResponse<'404', unknown, 'response:statuscode'>
    | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
    | FailureResponse<Exclude<StatusCode<1 | 3 | 4 | 5>, "400" | "404">, unknown, 'response:statuscode', IncomingHttpHeaders>
    >
    {
        return this.awaitResponse(this.client.get(\`user/\${path.username}\`, {
            responseType: 'json',
        }), {
            200: User,400: { safeParse: (x: unknown) => ({ success: true, data: x }) },404: { safeParse: (x: unknown) => ({ success: true, data: x }) },
        }) as ReturnType<this["getUserByName"]>
    }

    /**
     * GET /user/login
     * 
     * Logs user into the system
     */
    public loginUser({query}: {query?: { username?: string, password?: string }} = {}): Promise<
    | SuccessResponse<'200', LoginUserResponse>
    | FailureResponse<'400', unknown, 'response:statuscode'>
    | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
    | FailureResponse<Exclude<StatusCode<1 | 3 | 4 | 5>, "400">, unknown, 'response:statuscode', IncomingHttpHeaders>
    >
    {
        return this.awaitResponse(this.client.get('user/login', {
            searchParams: query ?? {},responseType: 'json',
        }), {
            200: LoginUserResponse,400: { safeParse: (x: unknown) => ({ success: true, data: x }) },
        }) as ReturnType<this["loginUser"]>
    }

    /**
     * GET /user/logout
     * 
     * Logs out current logged in user session
     */
    public logoutUser(): Promise<
    | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
    | FailureResponse<StatusCode<1 | 3 | 4 | 5>, string, 'response:statuscode', IncomingHttpHeaders>
    >
    {
        return this.awaitResponse(this.client.get('user/logout', {
            responseType: 'text',
        }), {
        }) as ReturnType<this["logoutUser"]>
    }

    /**
     * POST /store/order
     * 
     * Place an order for a pet
     * 
     * Place a new order in the store
     */
    public placeOrder({body}: {body: Order}): Promise<
    | SuccessResponse<'200', Order>
    | FailureResponse<'405', unknown, 'response:statuscode'>
    | FailureResponse<undefined, unknown, 'request:body', undefined>
    | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
    | FailureResponse<Exclude<StatusCode<1 | 3 | 4 | 5>, "405">, unknown, 'response:statuscode', IncomingHttpHeaders>
    >
    {
        const _body = this.validateRequestBody(Order, body)
        if ('left' in _body) {
        return Promise.resolve(_body)
        }


        return this.awaitResponse(this.client.post('store/order', {
            json: _body.right,responseType: 'json',
        }), {
            200: Order,405: { safeParse: (x: unknown) => ({ success: true, data: x }) },
        }) as ReturnType<this["placeOrder"]>
    }

    /**
     * PUT /pet
     * 
     * Update an existing pet
     * 
     * Update an existing pet by Id
     */
    public updatePet({body, auth = [['petstoreAuth']]}: {body: Pet, auth?: string[][] | string[]}): Promise<
    | SuccessResponse<'200', Pet>
    | FailureResponse<'400', unknown, 'response:statuscode'>
    | FailureResponse<'404', unknown, 'response:statuscode'>
    | FailureResponse<'405', unknown, 'response:statuscode'>
    | FailureResponse<undefined, unknown, 'request:body', undefined>
    | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
    | FailureResponse<Exclude<StatusCode<1 | 3 | 4 | 5>, "400" | "404" | "405">, unknown, 'response:statuscode', IncomingHttpHeaders>
    >
    {
        const _body = this.validateRequestBody(Pet, body)
        if ('left' in _body) {
        return Promise.resolve(_body)
        }


        return this.awaitResponse(this.buildClient(auth).put('pet', {
            json: _body.right,responseType: 'json',
        }), {
            200: Pet,400: { safeParse: (x: unknown) => ({ success: true, data: x }) },404: { safeParse: (x: unknown) => ({ success: true, data: x }) },405: { safeParse: (x: unknown) => ({ success: true, data: x }) },
        }) as ReturnType<this["updatePet"]>
    }

    /**
     * POST /pet/{petId}
     * 
     * Updates a pet in the store with form data
     */
    public updatePetWithForm({path, query, auth = [['petstoreAuth']]}: {path: { petId: string }, query?: { name?: string, status?: string }, auth?: string[][] | string[]}): Promise<
    | FailureResponse<'405', unknown, 'response:statuscode'>
    | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
    | FailureResponse<Exclude<StatusCode<1 | 3 | 4 | 5>, "405">, unknown, 'response:statuscode', IncomingHttpHeaders>
    >
    {
        return this.awaitResponse(this.buildClient(auth).post(\`pet/\${path.petId}\`, {
            searchParams: query ?? {},responseType: 'text',
        }), {
            405: { safeParse: (x: unknown) => ({ success: true, data: x }) },
        }) as ReturnType<this["updatePetWithForm"]>
    }

    /**
     * PUT /user/{username}
     * 
     * Update user
     * 
     * This can only be done by the logged in user.
     */
    public updateUser({body, path}: {body: User, path: { username: string }}): Promise<
    | FailureResponse<undefined, unknown, 'request:body', undefined>
    | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
    | FailureResponse<StatusCode<1 | 3 | 4 | 5>, string, 'response:statuscode', IncomingHttpHeaders>
    >
    {
        const _body = this.validateRequestBody(User, body)
        if ('left' in _body) {
        return Promise.resolve(_body)
        }


        return this.awaitResponse(this.client.put(\`user/\${path.username}\`, {
            json: _body.right,responseType: 'text',
        }), {
        }) as ReturnType<this["updateUser"]>
    }

    /**
     * POST /pet/{petId}/uploadImage
     * 
     * uploads an image
     */
    public uploadFile({body, path, query, auth = [['petstoreAuth']]}: {body: string | Buffer, path: { petId: string }, query?: { additionalMetadata?: string }, auth?: string[][] | string[]}): Promise<
    | SuccessResponse<'200', ApiResponse>
    | FailureResponse<StatusCode<2>, string, 'response:body', IncomingHttpHeaders>
    | FailureResponse<StatusCode<1 | 3 | 4 | 5>, string, 'response:statuscode', IncomingHttpHeaders>
    >
    {
        return this.awaitResponse(this.buildClient(auth).post(\`pet/\${path.petId}/uploadImage\`, {
            body: body,searchParams: query ?? {},responseType: 'json',
        }), {
            200: ApiResponse,
        }) as ReturnType<this["uploadFile"]>
    }

    public validateRequestBody<Body>(
    parser: { safeParse: (o: unknown) => SafeParseReturnType<unknown, Body> }, body: unknown )
    : {right: Body } | FailureResponse<undefined, unknown, 'request:body', undefined> {
        const _body = parser.safeParse(body)
        if (!_body.success)
        {
            return {success: false as const, statusCode: undefined, status: undefined, headers: undefined, left: body, error: _body.error, where: 'request:body' } satisfies FailureResponse<undefined, unknown, 'request:body', undefined>
        }
        return {right: _body.data}
    }

    public async awaitResponse<I, S extends Record<PropertyKey, { safeParse: (o: unknown) => SafeParseReturnType<unknown, I> }>>(response: 
    CancelableRequest<NoInfer<Response<I>>>
    , schemas: S) {
        const result = await response
        const status = result.statusCode < 200 ? 'informational' : result.statusCode < 300 ? 'success' : result.statusCode < 400 ? 'redirection' : result.statusCode < 500 ? 'client-error' : 'server-error'
        const validator = schemas[result.statusCode] ?? schemas.default
        const body = validator?.safeParse?.(result.body)
        if (result.statusCode < 200 || result.statusCode >= 300)
        {
            return {success: false as const, statusCode: result.statusCode.toString(), status, headers: result.headers, left: body?.success ? body.data : result.body, error: body !== undefined && !body.success ? body.error : undefined, where: 'response:statuscode' } 
        }
        if (body === undefined || !body.success)
        {
            return {success: body === undefined, statusCode: result.statusCode.toString(), status, headers: result.headers, left: result.body, error: body?.error, where: 'response:body' }
        }
        return {success: true as const, statusCode: result.statusCode.toString(), status, headers: result.headers, right: body.data }
    }

    protected buildPetstoreAuthClient(client: Got)
    {
        return client
    }


    protected buildApiKeyClient(client: Got)
    {
        return client.extend({
        hooks: {
        beforeRequest: [
        async (options) => 
        {
            const apiKey = this.auth.apiKey
            const key = typeof apiKey === 'function' ? await apiKey() : apiKey
            options.headers.api_key = key
        }
        ],},})
    }

    protected buildClient(auths: string[][] | string[] | undefined = this.defaultAuth, client?: Got): Got
    {
        const auth = (auths ?? [...this.availableAuth]).map(auth => Array.isArray(auth) ? auth : [auth]).filter((auth) => auth.every((a) => this.availableAuth.has(a)))
        let chosenClient = client ?? this.client
        for (const chosen of auth[0] ?? [])
        {
            if (chosen === 'petstoreAuth')
            {
                chosenClient = this.buildPetstoreAuthClient(chosenClient)
            }
            else
            if (chosen === 'apiKey')
            {
                chosenClient = this.buildApiKeyClient(chosenClient)
            }
        }
        return chosenClient
    }
}

export type Status<Major> = Major extends string ? Major extends \`1\${number}\`? 'informational': Major extends \`2\${number}\` ? 'success' : Major extends \`3\${number}\` ? 'redirection' : Major extends \`4\${number}\` ? 'client-error' : 'server-error' : undefined
export interface SuccessResponse<StatusCode extends string, T> { success: true; statusCode: StatusCode; status: Status<StatusCode>; headers: IncomingHttpHeaders; right: T }
export interface FailureResponse<StatusCode = string, T = unknown, Where = never, Headers = IncomingHttpHeaders> {
success: false
statusCode: StatusCode
status: Status<StatusCode>
headers: Headers
error: ZodError<T> | undefined
left: T
where: Where
}
export type StatusCode<Major extends number = 1 | 2 | 3 | 4 | 5> = \`\${Major}\${number}\`



",
    "examples/restclients/zod/petstore/petstore.zod.ts": "/**
* Generated by @skyleague/therefore@v1.0.0-local
* Do not manually touch this
*/
/* eslint-disable */

import { z } from 'zod'

export const Tag = z.object({
    id: z.number().int().optional(),
    name: z.string().optional(),
})

export const Category = z.object({
    id: z.number().int().optional(),
    name: z.string().optional(),
})

export const User = z.object({
    email: z.string().optional(),
    firstName: z.string().optional(),
    id: z.number().int().optional(),
    lastName: z.string().optional(),
    password: z.string().optional(),
    phone: z.string().optional(),
    username: z.string().optional(),
    userStatus: z.number().int().describe('User Status').optional(),
})

export const Pet = z.object({
    category: Category.optional(),
    id: z.number().int().optional(),
    name: z.string(),
    photoUrls: z.array(z.string()),
    status: z.enum(['available', 'pending', 'sold']).describe('pet status in the store').optional(),
    tags: z.array(Tag).optional(),
})

export const ApiResponse = z.object({
    code: z.number().int().optional(),
    message: z.string().optional(),
    type: z.string().optional(),
})

export const CreateUsersWithListInputRequest = z.array(User)

export const FindPetsByStatusResponse = z.array(Pet)

export const FindPetsByTagsResponse = z.array(Pet)

export const GetInventoryResponse = z.record(z.number().int().optional())

export const LoginUserResponse = z.string()

export const Order = z.object({
    complete: z.boolean().optional(),
    id: z.number().int().optional(),
    petId: z.number().int().optional(),
    quantity: z.number().int().optional(),
    shipDate: z.string().datetime({ offset: true }).optional(),
    status: z.enum(['placed', 'approved', 'delivered']).describe('Order Status').optional(),
})

export type ApiResponse = z.infer<typeof ApiResponse>

export type CreateUsersWithListInputRequest = z.infer<typeof CreateUsersWithListInputRequest>

export type FindPetsByStatusResponse = z.infer<typeof FindPetsByStatusResponse>

export type FindPetsByTagsResponse = z.infer<typeof FindPetsByTagsResponse>

export type GetInventoryResponse = z.infer<typeof GetInventoryResponse>

export type LoginUserResponse = z.infer<typeof LoginUserResponse>

export type Order = z.infer<typeof Order>

export type Pet = z.infer<typeof Pet>

export type User = z.infer<typeof User>

",
  },
}
`;
