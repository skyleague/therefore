/**
 * Generated by @skyleague/therefore
 * Do not manually touch this
 */
/* eslint-disable */

import { ValidationError } from 'ajv'
import type { DefinedError, ValidateFunction } from 'ajv'

import { validate as AgeonlyPersonValidator } from './schemas/ageonly-person.schema.js'
import { validate as MultipleOmitValidator } from './schemas/multiple-omit.schema.js'
import { validate as NameonlyPersonValidator } from './schemas/nameonly-person.schema.js'
import { validate as NonamePersonValidator } from './schemas/noname-person.schema.js'
import { validate as PersonValidator } from './schemas/person.schema.js'

export interface Person {
    name: string
    age: number
    nested: {
        pet: string
    }
}

export const Person = {
    validate: PersonValidator as ValidateFunction<Person>,
    get schema() {
        return Person.validate.schema
    },
    get errors() {
        return Person.validate.errors ?? undefined
    },
    is: (o: unknown): o is Person => Person.validate(o) === true,
    parse: (o: unknown): { right: Person } | { left: DefinedError[] } => {
        if (Person.is(o)) {
            return { right: o }
        }
        return { left: (Person.errors ?? []) as DefinedError[] }
    },
} as const

export type AgeonlyPerson = Pick<Person, 'age'>

export const AgeonlyPerson = {
    validate: AgeonlyPersonValidator as ValidateFunction<AgeonlyPerson>,
    get schema() {
        return AgeonlyPerson.validate.schema
    },
    get errors() {
        return AgeonlyPerson.validate.errors ?? undefined
    },
    is: (o: unknown): o is AgeonlyPerson => AgeonlyPerson.validate(o) === true,
    assert: (o: unknown) => {
        if (!AgeonlyPerson.validate(o)) {
            throw new ValidationError(AgeonlyPerson.errors ?? [])
        }
    },
    parse: (o: unknown): { right: AgeonlyPerson } | { left: DefinedError[] } => {
        if (AgeonlyPerson.is(o)) {
            return { right: o }
        }
        return { left: (AgeonlyPerson.errors ?? []) as DefinedError[] }
    },
} as const

export type MultipleOmit = Omit<Person, 'name' | 'age'>

export const MultipleOmit = {
    validate: MultipleOmitValidator as ValidateFunction<MultipleOmit>,
    get schema() {
        return MultipleOmit.validate.schema
    },
    get errors() {
        return MultipleOmit.validate.errors ?? undefined
    },
    is: (o: unknown): o is MultipleOmit => MultipleOmit.validate(o) === true,
    assert: (o: unknown) => {
        if (!MultipleOmit.validate(o)) {
            throw new ValidationError(MultipleOmit.errors ?? [])
        }
    },
    parse: (o: unknown): { right: MultipleOmit } | { left: DefinedError[] } => {
        if (MultipleOmit.is(o)) {
            return { right: o }
        }
        return { left: (MultipleOmit.errors ?? []) as DefinedError[] }
    },
} as const

export type NameonlyPerson = Pick<Person, 'name'>

export const NameonlyPerson = {
    validate: NameonlyPersonValidator as ValidateFunction<NameonlyPerson>,
    get schema() {
        return NameonlyPerson.validate.schema
    },
    get errors() {
        return NameonlyPerson.validate.errors ?? undefined
    },
    is: (o: unknown): o is NameonlyPerson => NameonlyPerson.validate(o) === true,
    assert: (o: unknown) => {
        if (!NameonlyPerson.validate(o)) {
            throw new ValidationError(NameonlyPerson.errors ?? [])
        }
    },
    parse: (o: unknown): { right: NameonlyPerson } | { left: DefinedError[] } => {
        if (NameonlyPerson.is(o)) {
            return { right: o }
        }
        return { left: (NameonlyPerson.errors ?? []) as DefinedError[] }
    },
} as const

export type NonamePerson = Omit<Person, 'name'>

export const NonamePerson = {
    validate: NonamePersonValidator as ValidateFunction<NonamePerson>,
    get schema() {
        return NonamePerson.validate.schema
    },
    get errors() {
        return NonamePerson.validate.errors ?? undefined
    },
    is: (o: unknown): o is NonamePerson => NonamePerson.validate(o) === true,
    assert: (o: unknown) => {
        if (!NonamePerson.validate(o)) {
            throw new ValidationError(NonamePerson.errors ?? [])
        }
    },
    parse: (o: unknown): { right: NonamePerson } | { left: DefinedError[] } => {
        if (NonamePerson.is(o)) {
            return { right: o }
        }
        return { left: (NonamePerson.errors ?? []) as DefinedError[] }
    },
} as const
