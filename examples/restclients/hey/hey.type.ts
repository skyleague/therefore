/**
 * Generated by @skyleague/therefore@v1.0.0-local
 * Do not manually touch this
 */
/* eslint-disable */

import type { DefinedError, ValidateFunction } from 'ajv'

import { validate as CallWithDuplicateResponsesResponse200Validator } from './schemas/call-with-duplicate-responses-response200.schema.js'
import { validate as CallWithResponseAndNoContentResponseResponse200Validator } from './schemas/call-with-response-and-no-content-response-response200.schema.js'
import { validate as CallWithResponsesResponse200Validator } from './schemas/call-with-responses-response200.schema.js'
import { validate as ComplexParamsRequestValidator } from './schemas/complex-params-request.schema.js'
import { validate as ComplexTypesResponseValidator } from './schemas/complex-types-response.schema.js'
import { validate as DictionaryWithArrayValidator } from './schemas/dictionary-with-array.schema.js'
import { validate as ModelFromZendeskValidator } from './schemas/model-from.zendesk.schema.js'
import { validate as ModelThatExtendsExtendsValidator } from './schemas/model-that-extends-extends.schema.js'
import { validate as ModelThatExtendsValidator } from './schemas/model-that-extends.schema.js'
import { validate as ModelWithBooleanValidator } from './schemas/model-with-boolean.schema.js'
import { validate as ModelWithOneOfEnumValidator } from './schemas/model-with-one-of-enum.schema.js'
import { validate as ModelWithReadOnlyAndWriteOnlyValidator } from './schemas/model-with-read-only-and-write-only.schema.js'
import { validate as ModelWithStringErrorValidator } from './schemas/model-with-string-error.schema.js'
import { validate as ModelWithStringValidator } from './schemas/model-with-string.schema.js'
import { validate as NonAsciiResponseValidator } from './schemas/non-ascii-response.schema.js'
import { validate as PostServiceWithEmptyTagRequestValidator } from './schemas/post-service-with-empty-tag-request.schema.js'
import { validate as TypesResponse200Validator } from './schemas/types-response200.schema.js'
import { validate as TypesResponse201Validator } from './schemas/types-response201.schema.js'
import { validate as TypesResponse202Validator } from './schemas/types-response202.schema.js'
import { validate as TypesResponse203Validator } from './schemas/types-response203.schema.js'
import { validate as UploadFileResponseValidator } from './schemas/upload-file-response.schema.js'

export type CallWithDuplicateResponsesResponse200 = ModelWithBoolean & ModelWithInteger

export const CallWithDuplicateResponsesResponse200 = {
    validate: CallWithDuplicateResponsesResponse200Validator as ValidateFunction<CallWithDuplicateResponsesResponse200>,
    get schema() {
        return CallWithDuplicateResponsesResponse200.validate.schema
    },
    get errors() {
        return CallWithDuplicateResponsesResponse200.validate.errors ?? undefined
    },
    is: (o: unknown): o is CallWithDuplicateResponsesResponse200 => CallWithDuplicateResponsesResponse200.validate(o) === true,
    parse: (o: unknown): { right: CallWithDuplicateResponsesResponse200 } | { left: DefinedError[] } => {
        if (CallWithDuplicateResponsesResponse200.is(o)) {
            return { right: o }
        }
        return { left: (CallWithDuplicateResponsesResponse200.errors ?? []) as DefinedError[] }
    },
} as const

export type CallWithResponseAndNoContentResponseResponse200 = number

export const CallWithResponseAndNoContentResponseResponse200 = {
    validate:
        CallWithResponseAndNoContentResponseResponse200Validator as ValidateFunction<CallWithResponseAndNoContentResponseResponse200>,
    get schema() {
        return CallWithResponseAndNoContentResponseResponse200.validate.schema
    },
    get errors() {
        return CallWithResponseAndNoContentResponseResponse200.validate.errors ?? undefined
    },
    is: (o: unknown): o is CallWithResponseAndNoContentResponseResponse200 =>
        CallWithResponseAndNoContentResponseResponse200.validate(o) === true,
    parse: (o: unknown): { right: CallWithResponseAndNoContentResponseResponse200 } | { left: DefinedError[] } => {
        if (CallWithResponseAndNoContentResponseResponse200.is(o)) {
            return { right: o }
        }
        return { left: (CallWithResponseAndNoContentResponseResponse200.errors ?? []) as DefinedError[] }
    },
} as const

export interface CallWithResponsesResponse200 {
    '@namespace.integer'?: number | undefined
    '@namespace.string'?: string | undefined
    value?: ModelWithString[] | undefined
}

export const CallWithResponsesResponse200 = {
    validate: CallWithResponsesResponse200Validator as ValidateFunction<CallWithResponsesResponse200>,
    get schema() {
        return CallWithResponsesResponse200.validate.schema
    },
    get errors() {
        return CallWithResponsesResponse200.validate.errors ?? undefined
    },
    is: (o: unknown): o is CallWithResponsesResponse200 => CallWithResponsesResponse200.validate(o) === true,
    parse: (o: unknown): { right: CallWithResponsesResponse200 } | { left: DefinedError[] } => {
        if (CallWithResponsesResponse200.is(o)) {
            return { right: o }
        }
        return { left: (CallWithResponsesResponse200.errors ?? []) as DefinedError[] }
    },
} as const

export interface ComplexParamsRequest {
    /**
     * @default true
     */
    enabled?: boolean | undefined
    key: string | null
    listOfModels?: ModelWithString[] | null | undefined
    listOfStrings?: string[] | null | undefined
    name: string | null
    parameters: ModelWithString | ModelWithEnum | ModelWithArray | ModelWithDictionary
    type: 'Monkey' | 'Horse' | 'Bird'
    user?:
        | {
              id?: number | undefined
              name?: string | null | undefined
          }
        | undefined
}

export const ComplexParamsRequest = {
    validate: ComplexParamsRequestValidator as ValidateFunction<ComplexParamsRequest>,
    get schema() {
        return ComplexParamsRequest.validate.schema
    },
    get errors() {
        return ComplexParamsRequest.validate.errors ?? undefined
    },
    is: (o: unknown): o is ComplexParamsRequest => ComplexParamsRequest.validate(o) === true,
    parse: (o: unknown): { right: ComplexParamsRequest } | { left: DefinedError[] } => {
        if (ComplexParamsRequest.is(o)) {
            return { right: o }
        }
        return { left: (ComplexParamsRequest.errors ?? []) as DefinedError[] }
    },
} as const

export type ComplexTypesResponse = ModelWithString[]

export const ComplexTypesResponse = {
    validate: ComplexTypesResponseValidator as ValidateFunction<ComplexTypesResponse>,
    get schema() {
        return ComplexTypesResponse.validate.schema
    },
    get errors() {
        return ComplexTypesResponse.validate.errors ?? undefined
    },
    is: (o: unknown): o is ComplexTypesResponse => ComplexTypesResponse.validate(o) === true,
    parse: (o: unknown): { right: ComplexTypesResponse } | { left: DefinedError[] } => {
        if (ComplexTypesResponse.is(o)) {
            return { right: o }
        }
        return { left: (ComplexTypesResponse.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * This is a complex dictionary
 */
export interface DictionaryWithArray {
    [k: string]: ModelWithString[] | undefined
}

export const DictionaryWithArray = {
    validate: DictionaryWithArrayValidator as ValidateFunction<DictionaryWithArray>,
    get schema() {
        return DictionaryWithArray.validate.schema
    },
    get errors() {
        return DictionaryWithArray.validate.errors ?? undefined
    },
    is: (o: unknown): o is DictionaryWithArray => DictionaryWithArray.validate(o) === true,
    parse: (o: unknown): { right: DictionaryWithArray } | { left: DefinedError[] } => {
        if (DictionaryWithArray.is(o)) {
            return { right: o }
        }
        return { left: (DictionaryWithArray.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * `Comment` or `VoiceComment`. The JSON object for adding voice comments to tickets is different. See [Adding voice comments to tickets](/documentation/ticketing/managing-tickets/adding-voice-comments-to-tickets)
 */
export type ModelFromZendesk = string

export const ModelFromZendesk = {
    validate: ModelFromZendeskValidator as ValidateFunction<ModelFromZendesk>,
    get schema() {
        return ModelFromZendesk.validate.schema
    },
    get errors() {
        return ModelFromZendesk.validate.errors ?? undefined
    },
    is: (o: unknown): o is ModelFromZendesk => ModelFromZendesk.validate(o) === true,
    parse: (o: unknown): { right: ModelFromZendesk } | { left: DefinedError[] } => {
        if (ModelFromZendesk.is(o)) {
            return { right: o }
        }
        return { left: (ModelFromZendesk.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * This is a model that extends another model
 */
export type ModelThatExtends = {} & ModelWithString & {
        propExtendsA?: string | undefined
        propExtendsB?: ModelWithString | undefined
    }

export const ModelThatExtends = {
    validate: ModelThatExtendsValidator as ValidateFunction<ModelThatExtends>,
    get schema() {
        return ModelThatExtends.validate.schema
    },
    get errors() {
        return ModelThatExtends.validate.errors ?? undefined
    },
    is: (o: unknown): o is ModelThatExtends => ModelThatExtends.validate(o) === true,
    parse: (o: unknown): { right: ModelThatExtends } | { left: DefinedError[] } => {
        if (ModelThatExtends.is(o)) {
            return { right: o }
        }
        return { left: (ModelThatExtends.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * This is a model that extends another model
 */
export type ModelThatExtendsExtends = {} & ModelWithString &
    ModelThatExtends & {
        propExtendsC?: string | undefined
        propExtendsD?: ModelWithString | undefined
    }

export const ModelThatExtendsExtends = {
    validate: ModelThatExtendsExtendsValidator as ValidateFunction<ModelThatExtendsExtends>,
    get schema() {
        return ModelThatExtendsExtends.validate.schema
    },
    get errors() {
        return ModelThatExtendsExtends.validate.errors ?? undefined
    },
    is: (o: unknown): o is ModelThatExtendsExtends => ModelThatExtendsExtends.validate(o) === true,
    parse: (o: unknown): { right: ModelThatExtendsExtends } | { left: DefinedError[] } => {
        if (ModelThatExtendsExtends.is(o)) {
            return { right: o }
        }
        return { left: (ModelThatExtendsExtends.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * This is a model with one property containing an array
 */
export interface ModelWithArray {
    prop?: ModelWithString[] | undefined
    propWithFile?: unknown[] | undefined
    propWithNumber?: number[] | undefined
}

/**
 * This is a model with one property containing an array
 */
export interface ModelWithArrayReadOnlyAndWriteOnly {
    prop?: ModelWithReadOnlyAndWriteOnly[] | undefined
    propWithFile?: unknown[] | undefined
    propWithNumber?: number[] | undefined
}

/**
 * This is a model with one boolean property
 */
export interface ModelWithBoolean {
    /**
     * This is a simple boolean property
     */
    prop?: boolean | undefined
}

export const ModelWithBoolean = {
    validate: ModelWithBooleanValidator as ValidateFunction<ModelWithBoolean>,
    get schema() {
        return ModelWithBoolean.validate.schema
    },
    get errors() {
        return ModelWithBoolean.validate.errors ?? undefined
    },
    is: (o: unknown): o is ModelWithBoolean => ModelWithBoolean.validate(o) === true,
    parse: (o: unknown): { right: ModelWithBoolean } | { left: DefinedError[] } => {
        if (ModelWithBoolean.is(o)) {
            return { right: o }
        }
        return { left: (ModelWithBoolean.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * This is a model with one property containing a dictionary
 */
export interface ModelWithDictionary {
    prop?:
        | {
              [k: string]: string | undefined
          }
        | undefined
}

/**
 * This is a model with one enum
 */
export interface ModelWithEnum {
    /**
     * Simple boolean enum
     */
    bool?: true | undefined
    /**
     * This is a simple enum with strings
     */
    'foo_bar-enum'?: 'Success' | 'Warning' | 'Error' | 'ØÆÅ字符串' | undefined
    /**
     * These are the HTTP error code enums
     */
    statusCode?: '100' | '200 FOO' | '300 FOO_BAR' | '400 foo-bar' | '500 foo.bar' | '600 foo&bar' | undefined
}

/**
 * This is a model with one number property
 */
export interface ModelWithInteger {
    /**
     * This is a simple number property
     */
    prop?: number | undefined
}

export type ModelWithOneOfEnum =
    | {
          foo: 'Bar'
      }
    | {
          foo: 'Baz'
      }
    | {
          foo: 'Qux'
      }
    | {
          content: string
          foo: 'Quux'
      }
    | {
          content: [string, string]
          foo: 'Corge'
      }

export const ModelWithOneOfEnum = {
    validate: ModelWithOneOfEnumValidator as ValidateFunction<ModelWithOneOfEnum>,
    get schema() {
        return ModelWithOneOfEnum.validate.schema
    },
    get errors() {
        return ModelWithOneOfEnum.validate.errors ?? undefined
    },
    is: (o: unknown): o is ModelWithOneOfEnum => ModelWithOneOfEnum.validate(o) === true,
    parse: (o: unknown): { right: ModelWithOneOfEnum } | { left: DefinedError[] } => {
        if (ModelWithOneOfEnum.is(o)) {
            return { right: o }
        }
        return { left: (ModelWithOneOfEnum.errors ?? []) as DefinedError[] }
    },
} as const

export interface ModelWithReadOnlyAndWriteOnly {
    bar: string
    baz: string
    foo: string
}

export const ModelWithReadOnlyAndWriteOnly = {
    validate: ModelWithReadOnlyAndWriteOnlyValidator as ValidateFunction<ModelWithReadOnlyAndWriteOnly>,
    get schema() {
        return ModelWithReadOnlyAndWriteOnly.validate.schema
    },
    get errors() {
        return ModelWithReadOnlyAndWriteOnly.validate.errors ?? undefined
    },
    is: (o: unknown): o is ModelWithReadOnlyAndWriteOnly => ModelWithReadOnlyAndWriteOnly.validate(o) === true,
    parse: (o: unknown): { right: ModelWithReadOnlyAndWriteOnly } | { left: DefinedError[] } => {
        if (ModelWithReadOnlyAndWriteOnly.is(o)) {
            return { right: o }
        }
        return { left: (ModelWithReadOnlyAndWriteOnly.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * This is a model with one string property
 */
export interface ModelWithString {
    /**
     * This is a simple string property
     */
    prop?: string | undefined
}

export const ModelWithString = {
    validate: ModelWithStringValidator as ValidateFunction<ModelWithString>,
    get schema() {
        return ModelWithString.validate.schema
    },
    get errors() {
        return ModelWithString.validate.errors ?? undefined
    },
    is: (o: unknown): o is ModelWithString => ModelWithString.validate(o) === true,
    parse: (o: unknown): { right: ModelWithString } | { left: DefinedError[] } => {
        if (ModelWithString.is(o)) {
            return { right: o }
        }
        return { left: (ModelWithString.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * This is a model with one string property
 */
export interface ModelWithStringError {
    /**
     * This is a simple string property
     */
    prop?: string | undefined
}

export const ModelWithStringError = {
    validate: ModelWithStringErrorValidator as ValidateFunction<ModelWithStringError>,
    get schema() {
        return ModelWithStringError.validate.schema
    },
    get errors() {
        return ModelWithStringError.validate.errors ?? undefined
    },
    is: (o: unknown): o is ModelWithStringError => ModelWithStringError.validate(o) === true,
    parse: (o: unknown): { right: ModelWithStringError } | { left: DefinedError[] } => {
        if (ModelWithStringError.is(o)) {
            return { right: o }
        }
        return { left: (ModelWithStringError.errors ?? []) as DefinedError[] }
    },
} as const

export type NonAsciiResponse = NonAsciiString[]

export const NonAsciiResponse = {
    validate: NonAsciiResponseValidator as ValidateFunction<NonAsciiResponse>,
    get schema() {
        return NonAsciiResponse.validate.schema
    },
    get errors() {
        return NonAsciiResponse.validate.errors ?? undefined
    },
    is: (o: unknown): o is NonAsciiResponse => NonAsciiResponse.validate(o) === true,
    parse: (o: unknown): { right: NonAsciiResponse } | { left: DefinedError[] } => {
        if (NonAsciiResponse.is(o)) {
            return { right: o }
        }
        return { left: (NonAsciiResponse.errors ?? []) as DefinedError[] }
    },
} as const

/**
 * A string with non-ascii (unicode) characters valid in typescript identifiers (æøåÆØÅöÔèÈ字符串)
 */
export type NonAsciiString = string

export type PostServiceWithEmptyTagRequest = ModelWithReadOnlyAndWriteOnly | ModelWithArrayReadOnlyAndWriteOnly

export const PostServiceWithEmptyTagRequest = {
    validate: PostServiceWithEmptyTagRequestValidator as ValidateFunction<PostServiceWithEmptyTagRequest>,
    get schema() {
        return PostServiceWithEmptyTagRequest.validate.schema
    },
    get errors() {
        return PostServiceWithEmptyTagRequest.validate.errors ?? undefined
    },
    is: (o: unknown): o is PostServiceWithEmptyTagRequest => PostServiceWithEmptyTagRequest.validate(o) === true,
    parse: (o: unknown): { right: PostServiceWithEmptyTagRequest } | { left: DefinedError[] } => {
        if (PostServiceWithEmptyTagRequest.is(o)) {
            return { right: o }
        }
        return { left: (PostServiceWithEmptyTagRequest.errors ?? []) as DefinedError[] }
    },
} as const

export type TypesResponse200 = number

export const TypesResponse200 = {
    validate: TypesResponse200Validator as ValidateFunction<TypesResponse200>,
    get schema() {
        return TypesResponse200.validate.schema
    },
    get errors() {
        return TypesResponse200.validate.errors ?? undefined
    },
    is: (o: unknown): o is TypesResponse200 => TypesResponse200.validate(o) === true,
    parse: (o: unknown): { right: TypesResponse200 } | { left: DefinedError[] } => {
        if (TypesResponse200.is(o)) {
            return { right: o }
        }
        return { left: (TypesResponse200.errors ?? []) as DefinedError[] }
    },
} as const

export type TypesResponse201 = string

export const TypesResponse201 = {
    validate: TypesResponse201Validator as ValidateFunction<TypesResponse201>,
    get schema() {
        return TypesResponse201.validate.schema
    },
    get errors() {
        return TypesResponse201.validate.errors ?? undefined
    },
    is: (o: unknown): o is TypesResponse201 => TypesResponse201.validate(o) === true,
    parse: (o: unknown): { right: TypesResponse201 } | { left: DefinedError[] } => {
        if (TypesResponse201.is(o)) {
            return { right: o }
        }
        return { left: (TypesResponse201.errors ?? []) as DefinedError[] }
    },
} as const

export type TypesResponse202 = boolean

export const TypesResponse202 = {
    validate: TypesResponse202Validator as ValidateFunction<TypesResponse202>,
    get schema() {
        return TypesResponse202.validate.schema
    },
    get errors() {
        return TypesResponse202.validate.errors ?? undefined
    },
    is: (o: unknown): o is TypesResponse202 => TypesResponse202.validate(o) === true,
    parse: (o: unknown): { right: TypesResponse202 } | { left: DefinedError[] } => {
        if (TypesResponse202.is(o)) {
            return { right: o }
        }
        return { left: (TypesResponse202.errors ?? []) as DefinedError[] }
    },
} as const

export interface TypesResponse203 {}

export const TypesResponse203 = {
    validate: TypesResponse203Validator as ValidateFunction<TypesResponse203>,
    get schema() {
        return TypesResponse203.validate.schema
    },
    get errors() {
        return TypesResponse203.validate.errors ?? undefined
    },
    is: (o: unknown): o is TypesResponse203 => TypesResponse203.validate(o) === true,
    parse: (o: unknown): { right: TypesResponse203 } | { left: DefinedError[] } => {
        if (TypesResponse203.is(o)) {
            return { right: o }
        }
        return { left: (TypesResponse203.errors ?? []) as DefinedError[] }
    },
} as const

export type UploadFileResponse = boolean

export const UploadFileResponse = {
    validate: UploadFileResponseValidator as ValidateFunction<UploadFileResponse>,
    get schema() {
        return UploadFileResponse.validate.schema
    },
    get errors() {
        return UploadFileResponse.validate.errors ?? undefined
    },
    is: (o: unknown): o is UploadFileResponse => UploadFileResponse.validate(o) === true,
    parse: (o: unknown): { right: UploadFileResponse } | { left: DefinedError[] } => {
        if (UploadFileResponse.is(o)) {
            return { right: o }
        }
        return { left: (UploadFileResponse.errors ?? []) as DefinedError[] }
    },
} as const
