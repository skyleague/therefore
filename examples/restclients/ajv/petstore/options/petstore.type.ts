/**
 * Generated by @skyleague/therefore
 * Do not manually touch this
 */
/* eslint-disable */

import { Ajv, ValidationError } from 'ajv'
import type { DefinedError } from 'ajv'
import addFormats from 'ajv-formats'
import type { FormatName } from 'ajv-formats'

import ApiResponseSchema from './schemas/api-response.schema.json' with { type: 'json' }
import CreateUsersWithListInputRequestSchema from './schemas/create-users-with-list-input-request.schema.json' with {
    type: 'json',
}
import FindPetsByStatusResponse200Schema from './schemas/find-pets-by-status-response200.schema.json' with { type: 'json' }
import FindPetsByTagsResponse200Schema from './schemas/find-pets-by-tags-response200.schema.json' with { type: 'json' }
import GetInventoryResponse200Schema from './schemas/get-inventory-response200.schema.json' with { type: 'json' }
import LoginUserResponse200Schema from './schemas/login-user-response200.schema.json' with { type: 'json' }
import OrderSchema from './schemas/order.schema.json' with { type: 'json' }
import PetSchema from './schemas/pet.schema.json' with { type: 'json' }
import UserSchema from './schemas/user.schema.json' with { type: 'json' }

export interface User {
    email?: string | undefined
    firstName?: string | undefined
    id?: number | undefined
    lastName?: string | undefined
    password?: string | undefined
    phone?: string | undefined
    username?: string | undefined
    /**
     * User Status
     */
    userStatus?: number | undefined
}

export const User = {
    validate: new Ajv({
        strict: true,
        strictSchema: false,
        strictTypes: true,
        strictTuples: false,
        useDefaults: true,
        logger: false,
        loopRequired: 5,
        loopEnum: 5,
        multipleOfPrecision: 4,
        code: { esm: true },
    }).compile<User>(UserSchema),
    schema: UserSchema,
    get errors() {
        return User.validate.errors ?? undefined
    },
    is: (o: unknown): o is User => User.validate(o) === true,
    assert: (o: unknown) => {
        if (!User.validate(o)) {
            throw new ValidationError(User.errors ?? [])
        }
    },
    parse: (o: unknown): { right: User } | { left: DefinedError[] } => {
        if (User.is(o)) {
            return { right: o }
        }
        return { left: (User.errors ?? []) as DefinedError[] }
    },
} as const

export interface Pet {
    category?: Category | undefined
    id?: number | undefined
    name: string
    photoUrls: string[]
    /**
     * pet status in the store
     */
    status?: 'available' | 'pending' | 'sold' | undefined
    tags?: Tag[] | undefined
}

export const Pet = {
    validate: new Ajv({
        strict: true,
        strictSchema: false,
        strictTypes: true,
        strictTuples: false,
        useDefaults: true,
        logger: false,
        loopRequired: 5,
        loopEnum: 5,
        multipleOfPrecision: 4,
        code: { esm: true },
    }).compile<Pet>(PetSchema),
    schema: PetSchema,
    get errors() {
        return Pet.validate.errors ?? undefined
    },
    is: (o: unknown): o is Pet => Pet.validate(o) === true,
    assert: (o: unknown) => {
        if (!Pet.validate(o)) {
            throw new ValidationError(Pet.errors ?? [])
        }
    },
    parse: (o: unknown): { right: Pet } | { left: DefinedError[] } => {
        if (Pet.is(o)) {
            return { right: o }
        }
        return { left: (Pet.errors ?? []) as DefinedError[] }
    },
} as const

export interface ApiResponse {
    code?: number | undefined
    message?: string | undefined
    type?: string | undefined
}

export const ApiResponse = {
    validate: new Ajv({
        strict: true,
        strictSchema: false,
        strictTypes: true,
        strictTuples: false,
        useDefaults: true,
        logger: false,
        loopRequired: 5,
        loopEnum: 5,
        multipleOfPrecision: 4,
        code: { esm: true },
    }).compile<ApiResponse>(ApiResponseSchema),
    schema: ApiResponseSchema,
    get errors() {
        return ApiResponse.validate.errors ?? undefined
    },
    is: (o: unknown): o is ApiResponse => ApiResponse.validate(o) === true,
    assert: (o: unknown) => {
        if (!ApiResponse.validate(o)) {
            throw new ValidationError(ApiResponse.errors ?? [])
        }
    },
    parse: (o: unknown): { right: ApiResponse } | { left: DefinedError[] } => {
        if (ApiResponse.is(o)) {
            return { right: o }
        }
        return { left: (ApiResponse.errors ?? []) as DefinedError[] }
    },
} as const

export interface Category {
    id?: number | undefined
    name?: string | undefined
}

export type CreateUsersWithListInputRequest = User[]

export const CreateUsersWithListInputRequest = {
    validate: new Ajv({
        strict: true,
        strictSchema: false,
        strictTypes: true,
        strictTuples: false,
        useDefaults: true,
        logger: false,
        loopRequired: 5,
        loopEnum: 5,
        multipleOfPrecision: 4,
        code: { esm: true },
    }).compile<CreateUsersWithListInputRequest>(CreateUsersWithListInputRequestSchema),
    schema: CreateUsersWithListInputRequestSchema,
    get errors() {
        return CreateUsersWithListInputRequest.validate.errors ?? undefined
    },
    is: (o: unknown): o is CreateUsersWithListInputRequest => CreateUsersWithListInputRequest.validate(o) === true,
    assert: (o: unknown) => {
        if (!CreateUsersWithListInputRequest.validate(o)) {
            throw new ValidationError(CreateUsersWithListInputRequest.errors ?? [])
        }
    },
    parse: (o: unknown): { right: CreateUsersWithListInputRequest } | { left: DefinedError[] } => {
        if (CreateUsersWithListInputRequest.is(o)) {
            return { right: o }
        }
        return { left: (CreateUsersWithListInputRequest.errors ?? []) as DefinedError[] }
    },
} as const

export type FindPetsByStatusResponse200 = Pet[]

export const FindPetsByStatusResponse200 = {
    validate: new Ajv({
        strict: true,
        strictSchema: false,
        strictTypes: true,
        strictTuples: false,
        useDefaults: true,
        logger: false,
        loopRequired: 5,
        loopEnum: 5,
        multipleOfPrecision: 4,
        code: { esm: true },
    }).compile<FindPetsByStatusResponse200>(FindPetsByStatusResponse200Schema),
    schema: FindPetsByStatusResponse200Schema,
    get errors() {
        return FindPetsByStatusResponse200.validate.errors ?? undefined
    },
    is: (o: unknown): o is FindPetsByStatusResponse200 => FindPetsByStatusResponse200.validate(o) === true,
    assert: (o: unknown) => {
        if (!FindPetsByStatusResponse200.validate(o)) {
            throw new ValidationError(FindPetsByStatusResponse200.errors ?? [])
        }
    },
    parse: (o: unknown): { right: FindPetsByStatusResponse200 } | { left: DefinedError[] } => {
        if (FindPetsByStatusResponse200.is(o)) {
            return { right: o }
        }
        return { left: (FindPetsByStatusResponse200.errors ?? []) as DefinedError[] }
    },
} as const

export type FindPetsByTagsResponse200 = Pet[]

export const FindPetsByTagsResponse200 = {
    validate: new Ajv({
        strict: true,
        strictSchema: false,
        strictTypes: true,
        strictTuples: false,
        useDefaults: true,
        logger: false,
        loopRequired: 5,
        loopEnum: 5,
        multipleOfPrecision: 4,
        code: { esm: true },
    }).compile<FindPetsByTagsResponse200>(FindPetsByTagsResponse200Schema),
    schema: FindPetsByTagsResponse200Schema,
    get errors() {
        return FindPetsByTagsResponse200.validate.errors ?? undefined
    },
    is: (o: unknown): o is FindPetsByTagsResponse200 => FindPetsByTagsResponse200.validate(o) === true,
    assert: (o: unknown) => {
        if (!FindPetsByTagsResponse200.validate(o)) {
            throw new ValidationError(FindPetsByTagsResponse200.errors ?? [])
        }
    },
    parse: (o: unknown): { right: FindPetsByTagsResponse200 } | { left: DefinedError[] } => {
        if (FindPetsByTagsResponse200.is(o)) {
            return { right: o }
        }
        return { left: (FindPetsByTagsResponse200.errors ?? []) as DefinedError[] }
    },
} as const

export interface GetInventoryResponse200 {
    [k: string]: number | undefined
}

export const GetInventoryResponse200 = {
    validate: new Ajv({
        strict: true,
        strictSchema: false,
        strictTypes: true,
        strictTuples: false,
        useDefaults: true,
        logger: false,
        loopRequired: 5,
        loopEnum: 5,
        multipleOfPrecision: 4,
        code: { esm: true },
    }).compile<GetInventoryResponse200>(GetInventoryResponse200Schema),
    schema: GetInventoryResponse200Schema,
    get errors() {
        return GetInventoryResponse200.validate.errors ?? undefined
    },
    is: (o: unknown): o is GetInventoryResponse200 => GetInventoryResponse200.validate(o) === true,
    assert: (o: unknown) => {
        if (!GetInventoryResponse200.validate(o)) {
            throw new ValidationError(GetInventoryResponse200.errors ?? [])
        }
    },
    parse: (o: unknown): { right: GetInventoryResponse200 } | { left: DefinedError[] } => {
        if (GetInventoryResponse200.is(o)) {
            return { right: o }
        }
        return { left: (GetInventoryResponse200.errors ?? []) as DefinedError[] }
    },
} as const

export type LoginUserResponse200 = string

export const LoginUserResponse200 = {
    validate: new Ajv({
        strict: true,
        strictSchema: false,
        strictTypes: true,
        strictTuples: false,
        useDefaults: true,
        logger: false,
        loopRequired: 5,
        loopEnum: 5,
        multipleOfPrecision: 4,
        code: { esm: true },
    }).compile<LoginUserResponse200>(LoginUserResponse200Schema),
    schema: LoginUserResponse200Schema,
    get errors() {
        return LoginUserResponse200.validate.errors ?? undefined
    },
    is: (o: unknown): o is LoginUserResponse200 => LoginUserResponse200.validate(o) === true,
    assert: (o: unknown) => {
        if (!LoginUserResponse200.validate(o)) {
            throw new ValidationError(LoginUserResponse200.errors ?? [])
        }
    },
    parse: (o: unknown): { right: LoginUserResponse200 } | { left: DefinedError[] } => {
        if (LoginUserResponse200.is(o)) {
            return { right: o }
        }
        return { left: (LoginUserResponse200.errors ?? []) as DefinedError[] }
    },
} as const

export interface Order {
    complete?: boolean | undefined
    id?: number | undefined
    petId?: number | undefined
    quantity?: number | undefined
    shipDate?: string | undefined
    /**
     * Order Status
     */
    status?: 'placed' | 'approved' | 'delivered' | undefined
}

export const Order = {
    validate: addFormats
        .default(
            new Ajv({
                strict: true,
                strictSchema: false,
                strictTypes: true,
                strictTuples: false,
                useDefaults: true,
                logger: false,
                loopRequired: 5,
                loopEnum: 5,
                multipleOfPrecision: 4,
                code: { esm: true },
            }),
            ['date-time'] as FormatName[],
        )
        .compile<Order>(OrderSchema),
    schema: OrderSchema,
    get errors() {
        return Order.validate.errors ?? undefined
    },
    is: (o: unknown): o is Order => Order.validate(o) === true,
    assert: (o: unknown) => {
        if (!Order.validate(o)) {
            throw new ValidationError(Order.errors ?? [])
        }
    },
    parse: (o: unknown): { right: Order } | { left: DefinedError[] } => {
        if (Order.is(o)) {
            return { right: o }
        }
        return { left: (Order.errors ?? []) as DefinedError[] }
    },
} as const

export interface Tag {
    id?: number | undefined
    name?: string | undefined
}
