/**
 * Generated by @skyleague/therefore@v1.0.0-local
 * Do not manually touch this
 */
/* eslint-disable */
import got from 'got'
import type { CancelableRequest, Got, Options, Response } from 'got'
import type { ValidateFunction, ErrorObject } from 'ajv'
import { IncomingHttpHeaders } from 'http'
import { File, OBErrorResponse1 } from './banking.type'

/**
 * Payment Initiation API
 *
 * Swagger for Payment Initiation API Specification
 */
export class Banking {
    public client: Got

    public auth: {
        psuoAuth2Security?: string | (() => Promise<string>)
        tppoAuth2Security?: string | (() => Promise<string>)
    }

    public availableAuth: Set<string>
    public defaultAuth: string[][] | string[] | undefined

    public constructor({
        prefixUrl = 'https://openbanking.org.uk',
        options,
        auth = {},
        defaultAuth,
    }: {
        prefixUrl?: string | 'https://openbanking.org.uk' | `${string}/open-banking/v3.1/pisp`
        options?: Options
        auth: {
            psuoAuth2Security?: string | (() => Promise<string>)
            tppoAuth2Security?: string | (() => Promise<string>)
        }
        defaultAuth?: string[][] | string[]
    }) {
        this.client = got.extend(...[{ prefixUrl, throwHttpErrors: false }, options].filter((o): o is Options => o !== undefined))
        this.auth = auth
        this.availableAuth = new Set(Object.keys(auth))
        this.defaultAuth = defaultAuth
    }

    /**
     * Get File Payment Consents
     */
    public async getFilePaymentConsentsConsentIdFile({
        path,
        headers,
        auth = [['tppoAuth2Security']],
    }: {
        path: { consentId: string }
        headers: {
            ['x-fapi-auth-date']?: string
            ['x-fapi-customer-ip-address']?: string
            ['x-fapi-interaction-id']?: string
            Authorization: string
            ['x-customer-user-agent']?: string
        }
        auth?: string[][] | string[]
    }) {
        return this.awaitResponse(
            this.buildClient(auth).get(`file-payment-consents/${path.consentId}/file`, {
                headers: headers,
                responseType: 'json',
            }),
            {
                200: File,
                400: OBErrorResponse1,
                401: { is: (x: unknown): x is unknown => true },
                403: OBErrorResponse1,
                404: { is: (x: unknown): x is unknown => true },
                405: { is: (x: unknown): x is unknown => true },
                406: { is: (x: unknown): x is unknown => true },
                429: { is: (x: unknown): x is unknown => true },
                500: OBErrorResponse1,
            }
        )
    }

    /**
     * Create File Payment Consents
     */
    public async createFilePaymentConsentsConsentIdFile({
        body,
        path,
        headers,
        auth = [['tppoAuth2Security']],
    }: {
        body: File
        path: { consentId: string }
        headers: {
            ['x-fapi-auth-date']?: string
            ['x-fapi-customer-ip-address']?: string
            ['x-fapi-interaction-id']?: string
            Authorization: string
            ['x-idempotency-key']: string
            ['x-jws-signature']: string
            ['x-customer-user-agent']?: string
        }
        auth?: string[][] | string[]
    }) {
        this.validateRequestBody(File, body)

        return this.awaitResponse(
            this.buildClient(auth).post(`file-payment-consents/${path.consentId}/file`, {
                json: body,
                headers: headers,
                responseType: 'json',
            }),
            {
                200: { is: (x: unknown): x is unknown => true },
                400: OBErrorResponse1,
                401: { is: (x: unknown): x is unknown => true },
                403: OBErrorResponse1,
                404: { is: (x: unknown): x is unknown => true },
                405: { is: (x: unknown): x is unknown => true },
                406: { is: (x: unknown): x is unknown => true },
                415: { is: (x: unknown): x is unknown => true },
                429: { is: (x: unknown): x is unknown => true },
                500: OBErrorResponse1,
            }
        )
    }

    public validateRequestBody<T>(schema: { is: (o: unknown) => o is T; assert: (o: unknown) => void }, body: T) {
        schema.assert(body)
        return body
    }

    public async awaitResponse<
        T,
        S extends Record<PropertyKey, undefined | { is: (o: unknown) => o is T; validate?: ValidateFunction<T> }>
    >(response: CancelableRequest<Response<unknown>>, schemas: S) {
        type FilterStartingWith<S extends PropertyKey, T extends string> = S extends number | string
            ? `${S}` extends `${T}${infer _X}`
                ? S
                : never
            : never
        type InferSchemaType<T> = T extends { is: (o: unknown) => o is infer S } ? S : never
        const result = await response
        const validator = schemas[result.statusCode] ?? schemas.default
        if (validator?.is(result.body) === false || result.statusCode < 200 || result.statusCode >= 300) {
            return {
                statusCode: result.statusCode,
                headers: result.headers,
                left: result.body,
                validationErrors: validator?.validate?.errors ?? undefined,
            } as {
                statusCode: number
                headers: IncomingHttpHeaders
                left: InferSchemaType<S[keyof S]>
                validationErrors?: ErrorObject[]
            }
        }
        return { statusCode: result.statusCode, headers: result.headers, right: result.body } as {
            statusCode: number
            headers: IncomingHttpHeaders
            right: InferSchemaType<S[keyof Pick<S, FilterStartingWith<keyof S, '2' | 'default'>>]>
        }
    }

    protected buildPsuoAuth2SecurityClient(client: Got) {
        return client
    }

    protected buildTppoAuth2SecurityClient(client: Got) {
        return client
    }

    protected buildClient(auths: string[][] | string[] | undefined = this.defaultAuth, client: Got = this.client): Got {
        const auth = (auths ?? [...this.availableAuth])
            .map((auth) => (Array.isArray(auth) ? auth : [auth]))
            .filter((auth) => auth.every((a) => this.availableAuth.has(a)))
        for (const chosen of auth[0] ?? []) {
            if (chosen === 'psuoAuth2Security') {
                client = this.buildPsuoAuth2SecurityClient(client)
            } else if (chosen === 'tppoAuth2Security') {
                client = this.buildTppoAuth2SecurityClient(client)
            }
        }
        return client
    }
}
