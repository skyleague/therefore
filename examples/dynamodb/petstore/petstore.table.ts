/**
 * Generated by @skyleague/therefore@v1.0.0-local
 * Do not manually touch this
 */
/* eslint-disable */

import type { DynamoDBServiceException } from '@aws-sdk/client-dynamodb'
import { GetCommand, PutCommand, UpdateCommand, paginateQuery, paginateScan } from '@aws-sdk/lib-dynamodb'
import type {
    DynamoDBDocument,
    GetCommandInput,
    PutCommandInput,
    QueryCommandInput,
    ScanCommandInput,
    UpdateCommandInput,
} from '@aws-sdk/lib-dynamodb'

import { GetPetResult, ListCategoriesByOwnerResult, ListPetsResult, PetEntity } from './petstore.type.js'
import type {
    CreatePetInput,
    GetPetInput,
    ListCategoriesByOwnerInput,
    ListPetsByOwnerInput,
    UpdatePetName1Input,
    UpdatePetNameInput,
} from './petstore.type.js'

export const createPetCommand = ({
    tableName,
    input: { category, createdAt, id, name, ownerId, photoUrls, status, tags, updatedAt },
}: {
    tableName: string
    input: CreatePetInput
}): PutCommandInput => {
    const _now = new Date().toISOString()
    return {
        TableName: tableName,
        Item: Object.fromEntries(
            Object.entries({
                // Key elements
                pk: `owner#${ownerId}`,
                sk: `pet#${id}`,
                entityType: 'pet',
                createdAt: createdAt ?? _now,
                updatedAt: updatedAt ?? _now,

                // Other properties
                category,
                id,
                name,
                ownerId,
                photoUrls,
                status,
                tags,
            }).filter(([, v]) => v !== undefined),
        ),
    }
}

export const getPetCommand = ({
    tableName,
    input: { ownerId, id },
}: {
    tableName: string
    input: GetPetInput
}): GetCommandInput => {
    return {
        TableName: tableName,
        Key: {
            pk: `owner#${ownerId}`,
            sk: `pet#${id}`,
        },
        ExpressionAttributeNames: {
            '#name': 'name',
            '#category': 'category',
        },
        ProjectionExpression: '#name, #category',
    }
}

export const listCategoriesByOwnerCommand = ({
    tableName,
    input: { ownerId },
}: {
    tableName: string
    input: ListCategoriesByOwnerInput
}): QueryCommandInput => {
    return {
        TableName: tableName,
        KeyConditionExpression: 'pk = :const1 AND begins_with(sk, :const0)',
        ExpressionAttributeValues: {
            ':const0': 'pet#',
            ':const1': `owner#${ownerId}`,
        },
        ExpressionAttributeNames: {
            '#category': 'category',
        },
        ProjectionExpression: '#category',
    }
}

export const listPetsCommand = ({
    tableName,
}: {
    tableName: string
}): ScanCommandInput => {
    return {
        TableName: tableName,
        ExpressionAttributeValues: {
            ':const0': 'pet',
        },
        ExpressionAttributeNames: {
            '#category': 'category',
        },
        ProjectionExpression: '#category',
        FilterExpression: 'entityType = :const0',
    }
}

export const listPetsByOwnerCommand = ({
    tableName,
    input: { ownerId },
}: {
    tableName: string
    input: ListPetsByOwnerInput
}): QueryCommandInput => {
    return {
        TableName: tableName,
        KeyConditionExpression: 'pk = :const1 AND begins_with(sk, :const0)',
        ExpressionAttributeValues: {
            ':const0': 'pet#',
            ':const1': `owner#${ownerId}`,
        },
    }
}

export class PetEntityClient {
    public entityType = 'pet' as const
    public table: PetDataTable

    public constructor({
        table,
    }: {
        table: PetDataTable
    }) {
        this.table = table
    }

    public async createPet({
        input,
    }: {
        input: CreatePetInput
    }) {
        const command = createPetCommand({
            tableName: this.table.tableName,
            input,
        })
        try {
            const result = await this.table.client.send(new PutCommand(command))
            return { right: null, $response: result }
        } catch (error) {
            return { left: error as DynamoDBServiceException, $response: error }
        }
    }

    public async getPet({
        input,
    }: {
        input: GetPetInput
    }) {
        const command = getPetCommand({
            tableName: this.table.tableName,
            input,
        })
        try {
            const result = await this.table.client.send(new GetCommand(command))
            if (result.Item === undefined) {
                return { right: null, $response: result }
            }
            return { ...GetPetResult.parse(result.Item), $response: result }
        } catch (error) {
            return { left: error as DynamoDBServiceException, $response: error }
        }
    }

    public async *listCategoriesByOwner({
        input,
    }: {
        input: ListCategoriesByOwnerInput
    }) {
        const command = listCategoriesByOwnerCommand({
            tableName: this.table.tableName,
            input,
        })
        try {
            for await (const page of paginateQuery({ client: this.table.client }, command)) {
                const items = (page.Items ?? []).map((x) => ListCategoriesByOwnerResult.parse(x))
                const rights = items.filter((x) => 'right' in x).map((x) => x.right)
                const lefts = items.filter((x) => 'left' in x).map((x) => x.left)

                if (lefts.length > 0) {
                    yield { left: rights, validationErrors: lefts, $response: page }
                } else {
                    yield { right: rights, $response: page }
                }
            }
        } catch (error) {
            yield { left: error as DynamoDBServiceException, $response: error }
        }
    }

    public async *listPets() {
        const command = listPetsCommand({
            tableName: this.table.tableName,
        })
        try {
            for await (const page of paginateScan({ client: this.table.client }, command)) {
                const items = (page.Items ?? []).map((x) => ListPetsResult.parse(x))
                const rights = items.filter((x) => 'right' in x).map((x) => x.right)
                const lefts = items.filter((x) => 'left' in x).map((x) => x.left)

                if (lefts.length > 0) {
                    yield { left: rights, validationErrors: lefts, $response: page }
                } else {
                    yield { right: rights, $response: page }
                }
            }
        } catch (error) {
            yield { left: error as DynamoDBServiceException, $response: error }
        }
    }

    public async *listPetsByOwner({
        input,
    }: {
        input: ListPetsByOwnerInput
    }) {
        const command = listPetsByOwnerCommand({
            tableName: this.table.tableName,
            input,
        })
        try {
            for await (const page of paginateQuery({ client: this.table.client }, command)) {
                const items = (page.Items ?? []).map((x) => PetEntity.parse(x))
                const rights = items.filter((x) => 'right' in x).map((x) => x.right)
                const lefts = items.filter((x) => 'left' in x).map((x) => x.left)

                if (lefts.length > 0) {
                    yield { left: rights, validationErrors: lefts, $response: page }
                } else {
                    yield { right: rights, $response: page }
                }
            }
        } catch (error) {
            yield { left: error as DynamoDBServiceException, $response: error }
        }
    }

    public async updatePetName({
        input,
    }: {
        input: UpdatePetNameInput
    }) {
        const command = updatePetNameCommand({
            tableName: this.table.tableName,
            input,
        })
        try {
            const result = await this.table.client.send(new UpdateCommand(command))
            return { right: null, $response: result }
        } catch (error) {
            return { left: error as DynamoDBServiceException, $response: error }
        }
    }

    public async updatePetName1({
        input,
    }: {
        input: UpdatePetName1Input
    }) {
        const command = updatePetName1Command({
            tableName: this.table.tableName,
            input,
        })
        try {
            const result = await this.table.client.send(new UpdateCommand(command))
            const data = PetEntity.parse(result.Attributes ?? {})
            return { ...data, $response: result }
        } catch (error) {
            return { left: error as DynamoDBServiceException, $response: error }
        }
    }
}

export class PetDataTable {
    public tableName = 'pet-data' as const

    public client: DynamoDBDocument

    public constructor({
        client,
    }: {
        client: DynamoDBDocument
    }) {
        this.client = client
    }
}

export const updatePetNameCommand = ({
    tableName,
    input: { ownerId, id, name },
}: {
    tableName: string
    input: UpdatePetNameInput
}): UpdateCommandInput => {
    return {
        TableName: tableName,
        Key: {
            pk: `owner#${ownerId}`,
            sk: `pet#${id}`,
        },
        ConditionExpression: '#category = :const0',
        UpdateExpression:
            'SET #name = if_not_exists(#name, :name), createdAt = if_not_exists(createdAt, :const1), updatedAt = :const1, entityType = if_not_exists(entityType, :const2)',
        ExpressionAttributeValues: {
            ':name': name,
            ':const0': (() => 'foo')(),
            ':const1': (() => new Date().toISOString())(),
            ':const2': 'pet',
        },
        ExpressionAttributeNames: {
            '#category': 'category',
            '#name': 'name',
        },
    }
}

export const updatePetName1Command = ({
    tableName,
    input: { ownerId, id, name, category },
}: {
    tableName: string
    input: UpdatePetName1Input
}): UpdateCommandInput => {
    return {
        TableName: tableName,
        Key: {
            pk: `owner#${ownerId}`,
            sk: `pet#${id}`,
        },
        ConditionExpression: '#category = :const0',
        UpdateExpression:
            'SET #category = :category, #name = if_not_exists(#name, :name), createdAt = if_not_exists(createdAt, :const1), updatedAt = :const1, entityType = if_not_exists(entityType, :const2)',
        ExpressionAttributeValues: {
            ':category': category,
            ':name': name,
            ':const0': (() => 'foo')(),
            ':const1': (() => new Date().toISOString())(),
            ':const2': 'pet',
        },
        ExpressionAttributeNames: {
            '#category': 'category',
            '#name': 'name',
        },

        // Extra options
        ReturnValues: 'ALL_NEW',
    }
}
