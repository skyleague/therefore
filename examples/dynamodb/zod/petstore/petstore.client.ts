/**
 * Generated by @skyleague/therefore
 * Do not manually touch this
 */
/* eslint-disable */

import type { DynamoDBServiceException } from '@aws-sdk/client-dynamodb'
import { DeleteCommand, GetCommand, PutCommand, UpdateCommand, paginateQuery, paginateScan } from '@aws-sdk/lib-dynamodb'
import type { DynamoDBDocument } from '@aws-sdk/lib-dynamodb'

import {
    createPetCommand,
    deletePetCommand,
    getPetCommand,
    listCategoriesByOwnerCommand,
    listPetEntityCollectionCommand,
    listPetsByOwnerCommand,
    listPetsBySkCommand,
    listPetsCommand,
    updatePetName1Command,
    updatePetNameCommand,
    upsertPetNameCommand,
} from './petstore.command.js'
import type {
    CreatePetInput,
    DeletePetInput,
    GetPetInput,
    ListPetEntityCollectionInput,
    UpdatePetName1Input,
    UpdatePetNameInput,
    UpsertPetNameInput,
} from './petstore.type.js'
import { GetPetResult, ListCategoriesByOwnerResult, ListPetsBySkResult, ListPetsResult, PetEntity } from './petstore.zod.js'

export class PetEntityClient {
    public entityType = 'pet' as const
    public table: PetDataTable

    public constructor({ table }: { table: PetDataTable }) {
        this.table = table
    }

    public async updatePetNameCommand(args: UpdatePetNameInput) {
        const command = updatePetNameCommand({ tableName: this.table.tableName, args })

        try {
            const result = await this.table.client.send(new UpdateCommand(command))
            return { right: null, $response: result }
        } catch (error) {
            return {
                success: false,
                left: error as DynamoDBServiceException,
                $response: error,
            }
        }
    }

    public async upsertPetNameCommand(args: UpsertPetNameInput) {
        const command = upsertPetNameCommand({ tableName: this.table.tableName, args })

        try {
            const result = await this.table.client.send(new UpdateCommand(command))
            return { right: null, $response: result }
        } catch (error) {
            return {
                success: false,
                left: error as DynamoDBServiceException,
                $response: error,
            }
        }
    }

    public async updatePetName1Command(args: UpdatePetName1Input) {
        const command = updatePetName1Command({ tableName: this.table.tableName, args })

        try {
            const result = await this.table.client.send(new UpdateCommand(command))
            const data = PetEntity.parse(result.Attributes ?? {})
            return { ...data, $response: result }
        } catch (error) {
            return {
                success: false,
                left: error as DynamoDBServiceException,
                $response: error,
            }
        }
    }

    public async getPetCommand(args: GetPetInput) {
        const command = getPetCommand({ tableName: this.table.tableName, args })

        try {
            const result = await this.table.client.send(new GetCommand(command))
            if (result.Item === undefined) {
                return { right: undefined, $response: result }
            }
            const parsed = GetPetResult.safeParse(result.Item)
            if (parsed.success) {
                return { success: true, right: parsed.data, $response: result }
            }
            return { success: false, left: parsed.error, $response: result }
        } catch (error) {
            return {
                success: false,
                left: error as DynamoDBServiceException,
                $response: error,
            }
        }
    }

    public async createPetCommand(args: CreatePetInput) {
        const command = createPetCommand({ tableName: this.table.tableName, args })

        try {
            const result = await this.table.client.send(new PutCommand(command))
            return { right: undefined, $response: result }
        } catch (error) {
            return {
                success: false,
                left: error as DynamoDBServiceException,
                $response: error,
            }
        }
    }

    public async *listPetsCommand() {
        const command = listPetsCommand({ tableName: this.table.tableName })

        try {
            for await (const page of paginateScan({ client: this.table.client }, command)) {
                for (const item of page.Items ?? []) {
                    const parsed = ListPetsResult.safeParse(item)
                    if (parsed.success) {
                        yield { success: true, right: parsed.data, $response: page }
                    } else {
                        yield { success: false, left: parsed.error, $response: page }
                    }
                }
            }
        } catch (error) {
            yield {
                success: false,
                left: error as DynamoDBServiceException,
                status: 'error' as const,
                $response: error,
            }
        }
    }

    public async *listPetsByOwnerCommand() {
        const command = listPetsByOwnerCommand({ tableName: this.table.tableName })

        try {
            for await (const page of paginateQuery({ client: this.table.client }, command)) {
                for (const item of page.Items ?? []) {
                    yield { ...PetEntity.parse(item), status: 'success' as const, $response: page }
                }
            }
        } catch (error) {
            yield {
                success: false,
                left: error as DynamoDBServiceException,
                status: 'error' as const,
                $response: error,
            }
        }
    }

    public async *listCategoriesByOwnerCommand() {
        const command = listCategoriesByOwnerCommand({ tableName: this.table.tableName })

        try {
            for await (const page of paginateQuery({ client: this.table.client }, command)) {
                for (const item of page.Items ?? []) {
                    yield { ...ListCategoriesByOwnerResult.parse(item), status: 'success' as const, $response: page }
                }
            }
        } catch (error) {
            yield {
                success: false,
                left: error as DynamoDBServiceException,
                status: 'error' as const,
                $response: error,
            }
        }
    }

    public async *listPetEntityCollectionCommand(args: ListPetEntityCollectionInput) {
        const command = listPetEntityCollectionCommand({ tableName: this.table.tableName, args })

        try {
            for await (const page of paginateQuery({ client: this.table.client }, command)) {
                for (const item of page.Items ?? []) {
                    yield { right: item, status: 'success' as const, $response: page }
                }
            }
        } catch (error) {
            yield {
                success: false,
                left: error as DynamoDBServiceException,
                status: 'error' as const,
                $response: error,
            }
        }
    }

    public async *listPetsBySkCommand() {
        const command = listPetsBySkCommand({ tableName: this.table.tableName })

        try {
            for await (const page of paginateQuery({ client: this.table.client }, command)) {
                for (const item of page.Items ?? []) {
                    yield { ...ListPetsBySkResult.parse(item), status: 'success' as const, $response: page }
                }
            }
        } catch (error) {
            yield {
                success: false,
                left: error as DynamoDBServiceException,
                status: 'error' as const,
                $response: error,
            }
        }
    }

    public async deletePetCommand(args: DeletePetInput) {
        const command = deletePetCommand({ tableName: this.table.tableName, args })

        try {
            const result = await this.table.client.send(new DeleteCommand(command))
            return { right: null, $response: result }
        } catch (error) {
            return {
                success: false,
                left: error as DynamoDBServiceException,
                $response: error,
            }
        }
    }
}

export class PetDataTable {
    public tableName: string
    public client: DynamoDBDocument

    public constructor({ client, tableName }: { client: DynamoDBDocument; tableName: string }) {
        this.client = client
        this.tableName = tableName
    }
}
