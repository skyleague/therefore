/**
 * Generated by @skyleague/therefore
 * Do not manually touch this
 */
/* eslint-disable */

import type { DynamoDBServiceException } from '@aws-sdk/client-dynamodb'
import { GetCommand, PutCommand, UpdateCommand, paginateScan } from '@aws-sdk/lib-dynamodb'
import type { DynamoDBDocument } from '@aws-sdk/lib-dynamodb'

import {
    createBicycleCommand,
    createBookCommand,
    createHomeImprovementCommand,
    getBicycleProjectionCommand,
    getBookReservedKeywordsCommand,
    getBookSpecialCharactersCommand,
    getHomeImprovementCommand,
    getProductsByColourAndPriceCommand,
    updateHomeImprovementCommand,
} from './product-catalog.command.js'
import type {
    CreateBicycleInput,
    CreateBookInput,
    CreateHomeImprovementInput,
    GetBicycleProjectionInput,
    GetBookReservedKeywordsInput,
    GetBookSpecialCharactersInput,
    GetHomeImprovementInput,
    GetProductsByColourAndPriceInput,
    UpdateHomeImprovementInput,
} from './product-catalog.type.js'
import {
    BicycleEntity,
    GetBicycleProjectionResult,
    GetBookReservedKeywordsResult,
    GetBookSpecialCharactersResult,
    HomeImprovementEntity,
} from './product-catalog.zod.js'

export class HomeImprovementEntityClient {
    public table: ProductCatalog

    public constructor({ table }: { table: ProductCatalog }) {
        this.table = table
    }

    public async createHomeImprovementCommand(args: CreateHomeImprovementInput) {
        const command = createHomeImprovementCommand({ tableName: this.table.tableName, args })

        try {
            const result = await this.table.client.send(new PutCommand(command))
            return { right: undefined, $response: result }
        } catch (error) {
            return {
                success: false,
                left: error as DynamoDBServiceException,
                $response: error,
            }
        }
    }

    public async updateHomeImprovementCommand(args: UpdateHomeImprovementInput) {
        const command = updateHomeImprovementCommand({ tableName: this.table.tableName, args })

        try {
            const result = await this.table.client.send(new UpdateCommand(command))
            return { right: null, $response: result }
        } catch (error) {
            return {
                success: false,
                left: error as DynamoDBServiceException,
                $response: error,
            }
        }
    }

    public async getHomeImprovementCommand(args: GetHomeImprovementInput) {
        const command = getHomeImprovementCommand({ tableName: this.table.tableName, args })

        try {
            const result = await this.table.client.send(new GetCommand(command))
            if (result.Item === undefined) {
                return { right: undefined, $response: result }
            }
            const parsed = HomeImprovementEntity.safeParse(result.Item)
            if (parsed.success) {
                return { success: true, right: parsed.data, $response: result }
            }
            return { success: false, left: parsed.error, $response: result }
        } catch (error) {
            return {
                success: false,
                left: error as DynamoDBServiceException,
                $response: error,
            }
        }
    }
}

export class BicycleEntityClient {
    public table: ProductCatalog

    public constructor({ table }: { table: ProductCatalog }) {
        this.table = table
    }

    public async createBicycleCommand(args: CreateBicycleInput) {
        const command = createBicycleCommand({ tableName: this.table.tableName, args })

        try {
            const result = await this.table.client.send(new PutCommand(command))
            return { right: undefined, $response: result }
        } catch (error) {
            return {
                success: false,
                left: error as DynamoDBServiceException,
                $response: error,
            }
        }
    }

    public async *getProductsByColourAndPriceCommand(args: GetProductsByColourAndPriceInput) {
        const command = getProductsByColourAndPriceCommand({ tableName: this.table.tableName, args })

        try {
            for await (const page of paginateScan({ client: this.table.client }, command)) {
                for (const item of page.Items ?? []) {
                    const parsed = BicycleEntity.safeParse(item)
                    if (parsed.success) {
                        yield { success: true, right: parsed.data, $response: page }
                    } else {
                        yield { success: false, left: parsed.error, $response: page }
                    }
                }
            }
        } catch (error) {
            yield {
                success: false,
                left: error as DynamoDBServiceException,
                status: 'error' as const,
                $response: error,
            }
        }
    }

    public async getBicycleProjectionCommand(args: GetBicycleProjectionInput) {
        const command = getBicycleProjectionCommand({ tableName: this.table.tableName, args })

        try {
            const result = await this.table.client.send(new GetCommand(command))
            if (result.Item === undefined) {
                return { right: undefined, $response: result }
            }
            const parsed = GetBicycleProjectionResult.safeParse(result.Item)
            if (parsed.success) {
                return { success: true, right: parsed.data, $response: result }
            }
            return { success: false, left: parsed.error, $response: result }
        } catch (error) {
            return {
                success: false,
                left: error as DynamoDBServiceException,
                $response: error,
            }
        }
    }
}

export class BookEntityClient {
    public table: ProductCatalog

    public constructor({ table }: { table: ProductCatalog }) {
        this.table = table
    }

    public async createBookCommand(args: CreateBookInput) {
        const command = createBookCommand({ tableName: this.table.tableName, args })

        try {
            const result = await this.table.client.send(new PutCommand(command))
            return { right: undefined, $response: result }
        } catch (error) {
            return {
                success: false,
                left: error as DynamoDBServiceException,
                $response: error,
            }
        }
    }

    public async getBookReservedKeywordsCommand(args: GetBookReservedKeywordsInput) {
        const command = getBookReservedKeywordsCommand({ tableName: this.table.tableName, args })

        try {
            const result = await this.table.client.send(new GetCommand(command))
            if (result.Item === undefined) {
                return { right: undefined, $response: result }
            }
            const parsed = GetBookReservedKeywordsResult.safeParse(result.Item)
            if (parsed.success) {
                return { success: true, right: parsed.data, $response: result }
            }
            return { success: false, left: parsed.error, $response: result }
        } catch (error) {
            return {
                success: false,
                left: error as DynamoDBServiceException,
                $response: error,
            }
        }
    }

    public async getBookSpecialCharactersCommand(args: GetBookSpecialCharactersInput) {
        const command = getBookSpecialCharactersCommand({ tableName: this.table.tableName, args })

        try {
            const result = await this.table.client.send(new GetCommand(command))
            if (result.Item === undefined) {
                return { right: undefined, $response: result }
            }
            const parsed = GetBookSpecialCharactersResult.safeParse(result.Item)
            if (parsed.success) {
                return { success: true, right: parsed.data, $response: result }
            }
            return { success: false, left: parsed.error, $response: result }
        } catch (error) {
            return {
                success: false,
                left: error as DynamoDBServiceException,
                $response: error,
            }
        }
    }
}

export class ProductCatalog {
    public tableName: string
    public client: DynamoDBDocument

    public constructor({ client, tableName }: { client: DynamoDBDocument; tableName: string }) {
        this.client = client
        this.tableName = tableName
    }
}
