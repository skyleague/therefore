/**
 * Generated by @skyleague/therefore@v1.0.0-local
 * Do not manually touch this
 */
/* eslint-disable */
import got, { Got, Options } from 'got'
import {
    ApiResponse,
    CreateUsersWithListInputRequest,
    FindPetsByStatusResponse,
    FindPetsByTagsResponse,
    GetInventoryResponse,
    LoginUserResponse,
    Order,
    Pet,
    User,
} from './petstore.type'

export class PetStore {
    public client: Got

    public auth: {
        petstoreAuth?: string | (() => Promise<string>)
        apiKey?: string | (() => Promise<string>)
    }

    public availableAuth: Set<string>
    public defaultAuth: string[][] | string[] | undefined

    public constructor({
        prefixUrl,
        options,
        auth = {},
        defaultAuth,
    }: {
        prefixUrl: string | `${string}/api/v3`
        options?: Options
        auth: {
            petstoreAuth?: string | (() => Promise<string>)
            apiKey?: string | (() => Promise<string>)
        }
        defaultAuth?: string[][] | string[]
    }) {
        this.client = got.extend(...[{ prefixUrl }, options].filter((o): o is Options => o !== undefined))
        this.auth = auth
        this.availableAuth = new Set(Object.keys(auth))
        this.defaultAuth = defaultAuth
    }

    /**
     * Update an existing pet
     *
     * Update an existing pet by Id
     */
    public async updatePet({ body, auth = [['petstoreAuth']] }: { body: Pet; auth?: string[][] | string[] }): Promise<Pet> {
        this.validateRequestBody(Pet, body)

        const result = await this.buildClient(auth)
            .put(`pet`, {
                json: body,
            })
            .json<Pet>()
        return this.validateResponse(Pet, result)
    }

    /**
     * Add a new pet to the store
     */
    public async addPet({ body, auth = [['petstoreAuth']] }: { body: Pet; auth?: string[][] | string[] }): Promise<Pet> {
        this.validateRequestBody(Pet, body)

        const result = await this.buildClient(auth)
            .post(`pet`, {
                json: body,
            })
            .json<Pet>()
        return this.validateResponse(Pet, result)
    }

    /**
     * Finds Pets by status
     *
     * Multiple status values can be provided with comma separated strings
     */
    public async findPetsByStatus({
        query,
        auth = [['petstoreAuth']],
    }: {
        query?: { status?: string }
        auth?: string[][] | string[]
    }): Promise<FindPetsByStatusResponse> {
        const result = await this.buildClient(auth)
            .get(`pet/findByStatus`, {
                searchParams: query ?? {},
            })
            .json<FindPetsByStatusResponse>()
        return this.validateResponse(FindPetsByStatusResponse, result)
    }

    /**
     * Finds Pets by tags
     *
     * Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.
     */
    public async findPetsByTags({
        query,
        auth = [['petstoreAuth']],
    }: {
        query?: { tags?: string }
        auth?: string[][] | string[]
    }): Promise<FindPetsByTagsResponse> {
        const result = await this.buildClient(auth)
            .get(`pet/findByTags`, {
                searchParams: query ?? {},
            })
            .json<FindPetsByTagsResponse>()
        return this.validateResponse(FindPetsByTagsResponse, result)
    }

    /**
     * Find pet by ID
     *
     * Returns a single pet
     */
    public async getPetById({
        path,
        auth = [['apiKey'], ['petstoreAuth']],
    }: {
        path: { petId: string }
        auth?: string[][] | string[]
    }): Promise<Pet> {
        const result = await this.buildClient(auth).get(`pet/${path.petId}`).json<Pet>()
        return this.validateResponse(Pet, result)
    }

    /**
     * Updates a pet in the store with form data
     */
    public async updatePetWithForm({
        path,
        query,
        auth = [['petstoreAuth']],
    }: {
        path: { petId: string }
        query?: { name?: string; status?: string }
        auth?: string[][] | string[]
    }): Promise<void> {
        await this.buildClient(auth)
            .post(`pet/${path.petId}`, {
                searchParams: query ?? {},
            })
            .json()
    }

    /**
     * Deletes a pet
     */
    public async deletePet({
        path,
        auth = [['petstoreAuth']],
    }: {
        path: { petId: string }
        auth?: string[][] | string[]
    }): Promise<void> {
        await this.buildClient(auth).delete(`pet/${path.petId}`).json()
    }

    /**
     * uploads an image
     */
    public async uploadFile({
        path,
        query,
        body,
        auth = [['petstoreAuth']],
    }: {
        path: { petId: string }
        query?: { additionalMetadata?: string }
        body: string | Buffer
        auth?: string[][] | string[]
    }): Promise<ApiResponse> {
        const result = await this.buildClient(auth)
            .post(`pet/${path.petId}/uploadImage`, {
                body: body,
                searchParams: query ?? {},
            })
            .json<ApiResponse>()
        return this.validateResponse(ApiResponse, result)
    }

    /**
     * Returns pet inventories by status
     *
     * Returns a map of status codes to quantities
     */
    public async getInventory({ auth = [['apiKey']] }: { auth?: string[][] | string[] }): Promise<GetInventoryResponse> {
        const result = await this.buildClient(auth).get(`store/inventory`).json<GetInventoryResponse>()
        return this.validateResponse(GetInventoryResponse, result)
    }

    /**
     * Place an order for a pet
     *
     * Place a new order in the store
     */
    public async placeOrder({ body }: { body: Order }): Promise<Order> {
        this.validateRequestBody(Order, body)

        const result = await this.client
            .post(`store/order`, {
                json: body,
            })
            .json<Order>()
        return this.validateResponse(Order, result)
    }

    /**
     * Find purchase order by ID
     *
     * For valid response try integer IDs with value <= 5 or > 10. Other values will generate exceptions.
     */
    public async getOrderById({ path }: { path: { orderId: string } }): Promise<Order> {
        const result = await this.client.get(`store/order/${path.orderId}`).json<Order>()
        return this.validateResponse(Order, result)
    }

    /**
     * Delete purchase order by ID
     *
     * For valid response try integer IDs with value < 1000. Anything above 1000 or nonintegers will generate API errors
     */
    public async deleteOrder({ path }: { path: { orderId: string } }): Promise<void> {
        await this.client.delete(`store/order/${path.orderId}`).json()
    }

    /**
     * Create user
     *
     * This can only be done by the logged in user.
     */
    public async createUser({ body }: { body: User }): Promise<void> {
        this.validateRequestBody(User, body)

        await this.client
            .post(`user`, {
                json: body,
            })
            .json()
    }

    /**
     * Creates list of users with given input array
     */
    public async createUsersWithListInput({ body }: { body: CreateUsersWithListInputRequest }): Promise<User> {
        this.validateRequestBody(CreateUsersWithListInputRequest, body)

        const result = await this.client
            .post(`user/createWithList`, {
                json: body,
            })
            .json<User>()
        return this.validateResponse(User, result)
    }

    /**
     * Logs user into the system
     */
    public async loginUser({ query }: { query?: { username?: string; password?: string } }): Promise<LoginUserResponse> {
        const result = await this.client
            .get(`user/login`, {
                searchParams: query ?? {},
            })
            .json<LoginUserResponse>()
        return this.validateResponse(LoginUserResponse, result)
    }

    /**
     * Logs out current logged in user session
     */
    public async logoutUser(): Promise<void> {
        await this.client.get(`user/logout`).json()
    }

    /**
     * Get user by user name
     */
    public async getUserByName({ path }: { path: { username: string } }): Promise<User> {
        const result = await this.client.get(`user/${path.username}`).json<User>()
        return this.validateResponse(User, result)
    }

    /**
     * Update user
     *
     * This can only be done by the logged in user.
     */
    public async updateUser({ path, body }: { path: { username: string }; body: User }): Promise<void> {
        this.validateRequestBody(User, body)

        await this.client
            .put(`user/${path.username}`, {
                json: body,
            })
            .json()
    }

    /**
     * Delete user
     *
     * This can only be done by the logged in user.
     */
    public async deleteUser({ path }: { path: { username: string } }): Promise<void> {
        await this.client.delete(`user/${path.username}`).json()
    }

    public validateRequestBody<T>(schema: { is: (o: unknown) => o is T; assert: (o: unknown) => void }, body: T) {
        schema.assert(body)
        return body
    }

    public validateResponse<T>(schema: { is: (o: unknown) => o is T; assert: (o: unknown) => void }, response: T) {
        schema.assert(response)
        return response
    }

    protected buildPetstoreAuthClient(client: Got) {
        return client
    }

    protected buildApiKeyClient(client: Got) {
        return client.extend({
            hooks: {
                beforeRequest: [
                    async (options) => {
                        const apiKey = this.auth.apiKey
                        const key = typeof apiKey === 'function' ? await apiKey() : apiKey
                        options.headers['api_key'] = key
                    },
                ],
            },
        })
    }

    protected buildClient(auths: string[][] | string[] | undefined = this.defaultAuth, client: Got = this.client): Got {
        const auth = (auths ?? [])
            .map((auth) => (Array.isArray(auth) ? auth : [auth]))
            .filter((auth) => auth.every((a) => this.availableAuth.has(a)))
        for (const chosen of auth[0] ?? []) {
            if (chosen === 'petstoreAuth') {
                client = this.buildPetstoreAuthClient(client)
            } else if (chosen === 'apiKey') {
                client = this.buildApiKeyClient(client)
            }
        }
        return client
    }
}
